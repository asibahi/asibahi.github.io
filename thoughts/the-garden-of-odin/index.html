<!doctype html>
<html  dir="ltr" >
	<!-- This site was built using Zola (getzola.com) and heavily edited version of the Hook theme (https://www.getzola.org/themes/hook/) -->

	<head>
		<meta charset="utf-8" />
		<!-- accent color in _theme.scss -->
		<meta name="theme-color" content=" rgb(203, 132, 0)" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta
			name="description"
			content="An Odin implementation of an abstract board game."
		/>
		<title>Abdul Rahman Sibahi | The Garden of Odin</title>
		<link rel="stylesheet" href="https://asibahi.github.io/style.css?h=5e9f4e540307a223aec7" />
	</head>

	<body>
		<a href="https://youtu.be/tXGQPGi-fZw">
			<img src=" /eagle.png" class="eagle" />
		</a>
		<div class="container">
			
	<header class="space">
		<a href="https:&#x2F;&#x2F;asibahi.github.io&#x2F;"> ⏏️ </a>

		
			<h1>The Garden of Odin</h1>
			
				<p class="secondary">An Odin implementation of an abstract board game.</p>
			

			<nav>
				
					<p class="secondary">2024-09-01</p>
				 
				<details class="secondary">
					<summary> Contents </summary>
					<ul>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#tiles">Tiles</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#board-representation">Board Representation</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#hand">Hand</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#the-game-object-first-draft">The Game Object - First Draft</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#bitboards">Bitboards</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#slotmaps">Slotmaps</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#groups-and-game-object-second-draft">Groups, and Game Object - Second Draft</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#the-game-rules">The Game Rules</a>
							
							<ul>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#tiles-1">Tiles</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#groups">Groups</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#the-structure">The Structure</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#placement">Placement</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#scoring">Scoring</a>
								</li>
								
							</ul>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#moves-and-game-object-third-draft">Moves, and Game Object - Third Draft</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#updating-the-game-state">Updating the Game State</a>
							
							<ul>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#group-section-init">group_section_init</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#group-attach-to-friendlies">group_attach_to_friendlies</a>
								</li>
								
							</ul>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#rethinking-groups">Rethinking Groups</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#back-to-updating-game-state">Back to Updating Game State</a>
							
							<ul>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#back-to-group-attach-to-friendlies">Back to group_attach_to_friendlies</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#group-attach-to-enemies">group_attach_to_enemies</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#game-update-state-inner-second-draft">game_update_state_inner - Second Draft</a>
								</li>
								
							</ul>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#game-regen-legal-moves">game_regen_legal_moves</a>
							
							<ul>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#oscillation">Oscillation</a>
								</li>
								
							</ul>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#first-bug">First Bug</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#rethinking-the-need-for-slotmap">Rethinking the Need for slotmap</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#visualizing-the-board">Visualizing the Board</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#the-example-game">The Example Game</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#second-bug">Second Bug</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#updated-board-visualization">Updated Board Visualization</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#back-to-the-second-bug">Back to the Second Bug</a>
							
							<ul>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#setting-up-the-debugger">Setting up the Debugger</a>
								</li>
								
								<li>
									<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#tedious-debugging">Tedious Debugging</a>
								</li>
								
							</ul>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#what-s-left">What&#x27;s left?</a>
							
						</li>
						
						<li>
							<a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#lessons-learned">Lessons Learned</a>
							
						</li>
						
					</ul>
				</details>
				
			</nav>
		
	</header>

			
			
	<main><p>In an escape from the worries of life, I have been reading recently into the <a href="https://odin-lang.org">Odin programming language</a>. I wanted to learn something that is closer to the metal than Rust, and Odin seems nice.</p>
<p>For a project to do with the language, I figured I would build a library for the abstract board game <a href="https://mindsports.nl/index.php/the-pit/526-dominions">Dominions, by Christian Freeling</a>. (<a href="https://senseis.xmp.net/?Dominions">Sensei's Library link</a>). The game can be described as a Go variant with distinct pieces, as opposed to Go itself where every "piece" is identical.</p>
<p>The game is <em>weird</em>. It is much less known than Freeling's other games like Havannah (for which I wrote <a href="https://github.com/asibahi/w9l">an implementation for in Rust</a>) and Grand Chess (which I designed and built a physical set for). Even Freeling himself does not put much stock into it, and is more interested in the tile set itself (which he calls <a href="https://mindsports.nl/index.php/puzzles/tilings/china-labyrinth/">the China Labyrinth</a>, even though they have nothing to do with China) than the game. He made other games with the tile set which you can find by browsing his site.</p>
<p>In code and my handwritten notes, I call the tile set <strong>Bustan</strong>: Arabic for Garden (hence the name of this article). Variety, branches, paths, and fences all make gardens seem like an appropriate metaphor for what is going on.</p>
<p>This is the sample game Freeling posted on his website:</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/dominions.png" alt="A game in progress of Dominions" /></p>
<p>I am writing this post as a way to organize my thoughts on how to represent the game in code. It is a semi organized, semi-chronologically-sorted brain dump: I am writing it as I iterate over the code. I will be talking mostly about how to represent the game in code form, leaving the rules for later. The end result can be found in the git history of the <a href="https://github.com/asibahi/bustan"><code>bustan</code> repository</a>.</p>
<h2 id="tiles">Tiles</h2>
<p>The most intriguing feature of Dominions, for me, is the tiles. There are many tile sets and game piece sets in the world of games: chess, dominoes, mahjong, playing cards, tarot. Dominions tiles are such a set.</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/cl-small-set.png" alt="Full set of Dominions Tiles" /></p>
<p>Each tile defines how it connects to its neighbors. They do not rotate, but they can be flipped to change controller (which is how capture happens in the game). A full set of tiles, pictured above, has 64 shapes.</p>
<p>A clever Id/numbering scheme for the tiles is described by Freeling.</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/numbering.png" alt="Full set of Dominions Tiles" /></p>
<p>Each side is assigned a power of two. So each piece unique id is simply the sum of which sides it connects. Binary system!</p>
<p>Each player starts the game with the full set of tiles, minus the Blank, the Zero-Tile, as it does not have a role in the game. So each tile has also, an owner.</p>
<p>During the game, control of tiles can be flipped from the owner to the opponent. After all one wins the game by controlling more tiles.</p>
<p>All this neatly fits into a <code>u8</code>! And Odin has bit-sets native into the language. When I was asking questions in Odin's discord, Ginger Bill (BDFL of Odin) suggested this structure.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-style:italic;color:#969896;">// 0b 0 0 _ 0 0 0 _ 0 0 0
</span><span style="font-style:italic;color:#969896;">//    | |   | | |   | | |
</span><span style="font-style:italic;color:#969896;">//    | |   | | |   | | Top_Right
</span><span style="font-style:italic;color:#969896;">//    | |   | | |   | Right
</span><span style="font-style:italic;color:#969896;">//    | |   | | |   Btm_Right
</span><span style="font-style:italic;color:#969896;">//    | |   | | Btm_Left
</span><span style="font-style:italic;color:#969896;">//    | |   | Left
</span><span style="font-style:italic;color:#969896;">//    | |   Top_Left
</span><span style="font-style:italic;color:#969896;">//    | Owner_Is_Host
</span><span style="font-style:italic;color:#969896;">//    Controller_Is_Host
</span><span style="font-style:italic;color:#969896;">//
</span><span style="font-style:italic;color:#969896;">// the two players are Guest and Host. Guest starts.
</span><span>
</span><span>Tile_Flag :: </span><span style="font-weight:bold;color:#a71d5d;">enum u8</span><span> {
</span><span>    Top_Rght,
</span><span>    Right,
</span><span>    Btm_Right,
</span><span>    Btm_Left,
</span><span>    Left,
</span><span>    Top_Left,
</span><span>    Owner_Is_Host,
</span><span>    Controller_Is_Host,
</span><span>}
</span><span>Tile :: </span><span style="font-weight:bold;color:#a71d5d;">distinct bit_set</span><span>[Tile_Flag;</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>]
</span></code></pre>
<p>The game starts with 126 unique tiles. Guest starts with the tiles <code>0b00_000_001</code> to <code>0b00_111_111</code> (or neatly in Octal: <code>0o001</code> to <code>0o077</code>). Host starts with the tiles <code>0b11_000_001</code> to <code>0b11_111_111</code> (<code>0o301</code> to <code>0o377</code>). The highest bit may flip during the game.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-style:italic;color:#969896;">// ^ is the pointer operator in Odin.
</span><span style="font-style:italic;color:#969896;">// ~ is bitwise XOR.
</span><span style="font-weight:bold;color:#795da3;">tile_flip</span><span>:: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(t: ^Tile) {
</span><span>    t^ ~= Tile{.Controller_Is_Host}
</span><span>}
</span></code></pre>
<h2 id="board-representation">Board Representation</h2>
<p>Here is where I go back and forth into reading Red Blob Games's <a href="https://www.redblobgames.com/grids/hexagons/">excellent guide to Hexagonal boards</a>.</p>
<p>The board of Dominions is a 9-sided hexagon. 217 cells. Ignoring tile placement restrictions for now, how to actually place tiles onto the board?</p>
<p>I oscillated (heh) between a few ideas, but eventually settled on a giant big array of <code>[217]Tile</code>, where an empty cell has the value <code>0</code><sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup>. To calculate offsets, I adapted the functions declared in the Red Blob article, and started with this neat loop (<code>N</code>, <code>CENTER</code>, and <code>CELL_COUNT</code> are compile-time constants based on the board's size):</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Board :: [CELL_COUNT]Tile
</span><span>
</span><span style="font-weight:bold;color:#795da3;">board_get_tile</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(back: ^[CELL_COUNT]Tile, hex: Hex) -&gt; (^Tile, </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">hex_distance</span><span>(hex, CENTER) &gt; N {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">nil</span><span>, </span><span style="color:#0086b3;">false
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// From RedBlob on representing Hexagonal boards with an array of arrays:
</span><span>    </span><span style="font-style:italic;color:#969896;">// Store Hex(q, r) at array[r][q - max(0, N-r)]. Row r size is 2*N+1 - abs(N-r).
</span><span>    </span><span style="font-style:italic;color:#969896;">// this loop calculates r&#39;s offset.
</span><span>
</span><span>    q, r := hex[</span><span style="color:#0086b3;">0</span><span>], hex[</span><span style="color:#0086b3;">1</span><span>]
</span><span>
</span><span>    r_len := </span><span style="color:#0086b3;">0
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> r_idx </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; r {
</span><span>        r_len += </span><span style="color:#0086b3;">2</span><span> * </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>(N) + </span><span style="color:#0086b3;">1</span><span> - </span><span style="color:#62a35c;">abs</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">int</span><span>(N - r_idx))
</span><span>    }
</span><span>
</span><span>    idx := r_len + </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>(q - </span><span style="color:#62a35c;">max</span><span>(</span><span style="color:#0086b3;">0</span><span>, N - r))
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> &amp;back[idx], </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>But having this loop run every time I make a look up is .. uncertain at best. So I decided to hardcode the row offsets:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">board_get_tile</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(back: ^[CELL_COUNT]Tile, hex: Hex) -&gt; (^Tile, </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">hex_distance</span><span>(hex, CENTER) &gt; N {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">nil</span><span>, </span><span style="color:#0086b3;">false
</span><span>    }
</span><span>
</span><span>    q, r := hex[</span><span style="color:#0086b3;">0</span><span>], hex[</span><span style="color:#0086b3;">1</span><span>]
</span><span>
</span><span>    r_len := </span><span style="color:#0086b3;">0
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> r {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">0</span><span>:
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">1</span><span>: r_len =   </span><span style="color:#0086b3;">9
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">2</span><span>: r_len =  </span><span style="color:#0086b3;">19
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">3</span><span>: r_len =  </span><span style="color:#0086b3;">30
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">4</span><span>: r_len =  </span><span style="color:#0086b3;">42
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">5</span><span>: r_len =  </span><span style="color:#0086b3;">55
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">6</span><span>: r_len =  </span><span style="color:#0086b3;">69
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">7</span><span>: r_len =  </span><span style="color:#0086b3;">84
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">8</span><span>: r_len = </span><span style="color:#0086b3;">100
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case  </span><span style="color:#0086b3;">9</span><span>: r_len = </span><span style="color:#0086b3;">117
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">10</span><span>: r_len = </span><span style="color:#0086b3;">133
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">11</span><span>: r_len = </span><span style="color:#0086b3;">148
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">12</span><span>: r_len = </span><span style="color:#0086b3;">162
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">13</span><span>: r_len = </span><span style="color:#0086b3;">175
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">14</span><span>: r_len = </span><span style="color:#0086b3;">187
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">15</span><span>: r_len = </span><span style="color:#0086b3;">198
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#0086b3;">16</span><span>: r_len = </span><span style="color:#0086b3;">208
</span><span>    }
</span><span>
</span><span>    idx := r_len + </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>(q - </span><span style="color:#62a35c;">max</span><span>(</span><span style="color:#0086b3;">0</span><span>, N - r))
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> &amp;back[idx], </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>This has the advantage of being "clean", with no wasted place in the array for unused coordinates.<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup> Cell lookup is O(1): when checking a cell, it is imperative to check its neighbors quickly to verify legal moves.</p>
<p>A separate data structure would be needed to track the tiles in player's hands (not in play yet).</p>
<p>An alternative idea is to represent <code>Tile</code> itself by a struct, that holds data whether the tile is in play, and if so its location on the board. However, the only way to quickly query the tile's neighbors is to iterate over every tile at every check to know where it is. Might as well stuff them all in an array.</p>
<h2 id="hand">Hand</h2>
<p>Following the same idea from representing the board, Hands are better implemented as a fixed array. Initializing a full set of hands for both players by transmuting a <code>u8</code> into a <code>Tile</code>. <em>That is</em> why I wanted <code>Tile</code>s to be <code>u8</code>s to begin with!!</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>HAND_SIZE :: </span><span style="color:#0086b3;">63
</span><span>Hand :: </span><span style="font-weight:bold;color:#a71d5d;">distinct</span><span> [HAND_SIZE]Tile
</span><span>
</span><span style="font-weight:bold;color:#795da3;">hands_init</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() -&gt; (guest: Hand, host: Hand) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>(HAND_SIZE) {
</span><span>        guest[i] = </span><span style="font-weight:bold;color:#a71d5d;">transmute</span><span>(Tile)(i + </span><span style="color:#0086b3;">0o001</span><span>)
</span><span>        host[i]  = </span><span style="font-weight:bold;color:#a71d5d;">transmute</span><span>(Tile)(i + </span><span style="color:#0086b3;">0o301</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>Also, to check the legality of move, the player has to have the tile available to play, so I defined a couple of helper <del>methods</del> procedures.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">hand_has_tile</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(hand: Hand, id: </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> {
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#0086b3;">0</span><span> &lt; id, </span><span style="color:#183691;">&quot;Blank Tile is not playable&quot;</span><span>)
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(id &lt;= HAND_SIZE, </span><span style="color:#183691;">&quot;Tile is impossible&quot;</span><span>)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> !</span><span style="color:#62a35c;">tile_is_empty</span><span>(hand[id - </span><span style="color:#0086b3;">1</span><span>])
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">hand_get_tile</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(hand: ^Hand, id: </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>) -&gt; (Tile, </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !</span><span style="color:#62a35c;">hand_has_tile</span><span>(hand^, id) </span><span style="font-weight:bold;color:#a71d5d;">do return </span><span style="color:#0086b3;">nil</span><span>, </span><span style="color:#0086b3;">false
</span><span>
</span><span>    ret := hand[id - </span><span style="color:#0086b3;">1</span><span>]
</span><span>    hand[id - </span><span style="color:#0086b3;">1</span><span>] = {}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> ret, </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>About here, I thought I would like to test my logic. So I took advantage of Odin's testing framework with a couple of simple asserts. Note that I put these in the same file as the procedures they test, and they worked just fine. They are all prefixed with <code>test_*</code> not to pollute the autocompletion too much.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:testing&quot;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">@(test)
</span><span style="font-weight:bold;color:#795da3;">test_hand_get_tile</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(t: ^testing.T) {
</span><span>    w, _ := </span><span style="color:#62a35c;">hands_init</span><span>()
</span><span>
</span><span>    tile: Tile
</span><span>    ok: </span><span style="font-weight:bold;color:#a71d5d;">bool
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// should be successful
</span><span>    tile, ok = </span><span style="color:#62a35c;">hand_get_tile</span><span>(&amp;w, </span><span style="color:#0086b3;">63</span><span>)
</span><span>    testing.</span><span style="color:#62a35c;">expect</span><span>(t, !</span><span style="color:#62a35c;">tile_is_empty</span><span>(tile))
</span><span>    testing.</span><span style="color:#62a35c;">expect</span><span>(t, ok)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// should fail. tile was emptied
</span><span>    tile, ok = </span><span style="color:#62a35c;">hand_get_tile</span><span>(&amp;w, </span><span style="color:#0086b3;">63</span><span>)
</span><span>    testing.</span><span style="color:#62a35c;">expect</span><span>(t, </span><span style="color:#62a35c;">tile_is_empty</span><span>(tile))
</span><span>    testing.</span><span style="color:#62a35c;">expect</span><span>(t, !ok)
</span><span>}
</span><span style="font-style:italic;color:#969896;">// other tests go here
</span></code></pre>
<p>After that, I figured I would make sure for every weird logic I make I'd have to write a bunch of tests to .. test it, and sanity check my code.</p>
<h2 id="the-game-object-first-draft"><em>The</em> Game Object - First Draft</h2>
<p>Now that I have the basic, naïve framework of the game's representation, I started looking into it from the other side: top down.</p>
<p>Looking at different game libraries, to see which API they provide and how they allow their users to interact with the internal rules engine. The <a href="https://docs.rs/shakmaty/latest/shakmaty/">shakmaty crate</a> has been of great help in the past, as well as the <a href="https://docs.rs/goban/0.18.1/goban/">goban crate</a>. JaniM from the Rust discord also shared with me their <a href="https://github.com/JaniM/variant-go-server">Variant Go Server</a>. I also looked back at my <a href="https://github.com/asibahi/w9l">Havannah implementation</a> which I did last year to remember how I structured things. (Maybe I'd tool both into WASM modules. How about that?)</p>
<p>Most of these structure their API around a specific object: the <em>Game</em> object, which is interacted with by querying legal moves, making moves, and, optionally, undoing moves. That's it. The Game object tracks the state of all elements in the game.</p>
<p>The most straightforward way to do that is a struct. I do not really know if this is the "optimal" arrangement of fields, but I am doing what makes sense to me.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Player :: </span><span style="font-weight:bold;color:#a71d5d;">enum u8</span><span> {
</span><span>    Guest, </span><span style="font-style:italic;color:#969896;">// White. Goes first.
</span><span>    Host,  </span><span style="font-style:italic;color:#969896;">// Black
</span><span>}
</span><span>
</span><span>Status :: </span><span style="font-weight:bold;color:#a71d5d;">enum u8</span><span> {
</span><span>    Ongoing,
</span><span>    Guest_Win,
</span><span>    Host_Win,
</span><span>    Tie,
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#969896;">// The Object of attention
</span><span>Game :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    board:                 Board,
</span><span>    to_play:               Player,
</span><span>    status:                Status,
</span><span>    guest_hand, host_hand: Hand,
</span><span>    </span><span style="font-style:italic;color:#969896;">// ... more to come
</span><span>}
</span></code></pre>
<p>To inquire about moves, a <code>Move</code> struct is needed<sup class="footnote-reference" id="fr-3-1"><a href="#fn-3">3</a></sup>. A move is simply a placement of a <code>Tile</code> on <code>Hex</code>. Whose tile and whose turn are ideally tracked and verified by the Game object.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Move :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    hex:  Hex,
</span><span>    tile: Tile,
</span><span>}
</span></code></pre>
<p>This misses one big thing: Groups. Dominions is a game of territory, based on Go. Tiles together make Groups. Groups have liberties, which they live and die of. Groups capture other Groups. The winner is the player with bigger Groups. Groups are important.</p>
<h2 id="bitboards">Bitboards</h2>
<p>Before talking about Groups, <a href="https://en.wikipedia.org/wiki/Bitboard">Bitboards</a> warrant an introduction.</p>
<p>Bitboards are, at their core, based on a simple observations: a chessboard has 64 squares, and a <code>u64</code> has 64 bits. By tying each bit address to a specific square, <em>any</em> binary value can be mapped.</p>
<p>In chess implementations: There is a bitboard (read: a <code>u64</code>) to mark where all the White pieces are. There is another bitboard to mark where all the squares the Queen sees are.</p>
<p>The other advantage of bitboards is that, since they are just bits, they have bit operations. With a bitboard showing the white pieces are and a bitboard showing where black's pieces can move next turn: just <code>AND</code> them together and there is now a new bitboard of which pieces of white are under attack. They are small, simple integers, and operating on them is as easy as integers.</p>
<p>Unfortunately, however, the Dominions board is decidedly <em>not</em> 64 cells, or any such convenient number. It is 217 cells. It would be possible to represent the whole board with a 217bit integer, should it exist, but the largest bit set Odin provides is 128 bits. But have no fear! An array of 7 bit sets can solve the problem, as 7 <code>u32</code> integers can fit the needed 217 bits and more (namely 224 bits). This is as small as can be. Thanks to Odin's array programming (which is also taken advantage of for Hex math), using bitwise operations on these bitboards is as easy as they are on usual bit-sets. The additional 7 bits can be used for metadata, as well.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Bitboard :: </span><span style="font-weight:bold;color:#a71d5d;">distinct </span><span>[</span><span style="color:#0086b3;">7</span><span>]</span><span style="font-weight:bold;color:#a71d5d;">bit_set</span><span>[</span><span style="color:#0086b3;">0</span><span> ..&lt; </span><span style="color:#0086b3;">32</span><span>;</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span>] </span><span style="font-style:italic;color:#969896;">// 7 * 32 = 224
</span><span>PLAY_AREA: Bitboard : {~{}, ~{}, ~{}, ~{}, ~{}, ~{}, ~{</span><span style="color:#0086b3;">25</span><span>, </span><span style="color:#0086b3;">26</span><span>, </span><span style="color:#0086b3;">27</span><span>, </span><span style="color:#0086b3;">28</span><span>, </span><span style="color:#0086b3;">29</span><span>, </span><span style="color:#0086b3;">30</span><span>, </span><span style="color:#0086b3;">31</span><span>}}
</span><span>DATA_AREA: Bitboard : {{}, {}, {}, {}, {}, {}, {</span><span style="color:#0086b3;">25</span><span>, </span><span style="color:#0086b3;">26</span><span>, </span><span style="color:#0086b3;">27</span><span>, </span><span style="color:#0086b3;">28</span><span>, </span><span style="color:#0086b3;">29</span><span>, </span><span style="color:#0086b3;">30</span><span>, </span><span style="color:#0086b3;">31</span><span>}} </span><span style="font-style:italic;color:#969896;">// Extra bits for metadata
</span><span>
</span><span style="font-style:italic;color:#969896;">// helper procedure for common maths
</span><span style="font-weight:bold;color:#a71d5d;">@</span><span>(private = </span><span style="color:#183691;">&quot;file&quot;</span><span>)
</span><span style="font-weight:bold;color:#795da3;">bit_to_col_row</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(bit: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) -&gt; (col, row: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) {
</span><span>    col = bit % </span><span style="color:#0086b3;">32
</span><span>    row = bit / </span><span style="color:#0086b3;">32
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">bb_set_bit</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(bb: ^Bitboard, bit: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// assert here to allow an unchecked version for meta data
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#0086b3;">0</span><span> &lt;= bit &amp;&amp; bit &lt; CELL_COUNT)
</span><span>    col, row := </span><span style="color:#62a35c;">bit_to_col_row</span><span>(bit)
</span><span>    bb^[row] |= {col}
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">bb_get_bit</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(bb: Bitboard, bit: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> {
</span><span>    col, row := </span><span style="color:#62a35c;">bit_to_col_row</span><span>(bit)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> col </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> bb[row]
</span><span>}
</span></code></pre>
<p>Not to get ahead of the topic, but merging two of these bitboards (bitwise <code>OR</code>) is now as simple as this:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">group_capture</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(blessed, cursed: ^Group) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// ----- snipped
</span><span>    blessed.tiles |= cursed.tiles </span><span style="font-style:italic;color:#969896;">// `tiles` field is a Bitboard
</span><span>    </span><span style="font-style:italic;color:#969896;">// ----- snipped
</span><span>}
</span></code></pre>
<p>As an addition, I implemented an iterator over the set bits in <code>Bitboard</code>. Odin has nice syntax to iterate over the set flags in a bit-set, but an array of bit-sets presents a logistical challenge. I hacked at it for a couple of hours and came up with the following. Odin's implementation of iterators is, all considered, fairly easy.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-style:italic;color:#969896;">// The State machine
</span><span>Bitboard_Iterator :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    bb:   Bitboard,
</span><span>    next: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>,
</span><span>}
</span><span style="font-weight:bold;color:#795da3;">bb_make_iter</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(bb: Bitboard) -&gt; (it: Bitboard_Iterator) {
</span><span>    it.bb = bb &amp; PLAY_AREA
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#969896;">// The iterator procedure
</span><span style="font-weight:bold;color:#795da3;">bb_iter</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(it: ^Bitboard_Iterator) -&gt; (item: Hex, idx: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> it.next ..&lt; CELL_COUNT {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">bb_get_bit</span><span>(it.bb, i) {
</span><span>            item = </span><span style="color:#62a35c;">hex_from_index</span><span>(i)
</span><span>            idx = i
</span><span>            it.next = i + </span><span style="color:#0086b3;">1
</span><span>            ok = </span><span style="color:#0086b3;">true
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#969896;">// And it is used such:
</span><span>bbi := </span><span style="color:#62a35c;">bb_make_iter</span><span>(bitboard_from_somewhere)
</span><span style="font-weight:bold;color:#a71d5d;">for</span><span> hex, idx </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#62a35c;">bb_iter</span><span>(&amp;bbi) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// do something with this hex or its corresponding index
</span><span>}
</span></code></pre>
<p>With the help of the Hex to Index math mentioned earlier in <code>Board</code> (and I have by now extracted it to another procedure), each bit in the bitboard can be quickly mapped to its corresponding Hex.</p>
<p>Which would bring the topic back to Groups, but there is another detour.</p>
<h2 id="slotmaps">Slotmaps</h2>
<p>In my implementation of Havannah (linked earlier), I used the <code>slotmap</code> Rust crate to track groups. Odin does not have a slotmap<sup class="footnote-reference" id="fr-4-1"><a href="#fn-4">4</a></sup> in its core library. There is <a href="https://gist.github.com/gingerBill/7282ff54744838c52cc80c559f697051">a sample showcase implementation by Ginger Bill</a>, but I wanted to try my hand at this FFI thing. With help from the Rust and Odin discords to navigate the FFI of both languages, I did the following, and it works! Almost statically type checked from both sides, too.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">use </span><span>slotmap::{DefaultKey, Key, KeyData, SlotMap};
</span><span>
</span><span style="font-style:italic;color:#969896;">// The Rust code does not need to manipulate the object in anyway.
</span><span style="font-style:italic;color:#969896;">// Type erased `*mut c_void` is all Rust knows: only a pointer.
</span><span style="font-weight:bold;color:#a71d5d;">type </span><span>SmItem </span><span style="font-weight:bold;color:#a71d5d;">= *mut </span><span>core::ffi::</span><span style="font-weight:bold;color:#a71d5d;">c_void</span><span>;
</span><span style="font-weight:bold;color:#a71d5d;">type </span><span>SmPtr </span><span style="font-weight:bold;color:#a71d5d;">= *mut </span><span>SlotMap&lt;DefaultKey, SmItem&gt;;
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_init</span><span>() -&gt; SmPtr {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> sm </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span>::new(SlotMap::&lt;</span><span style="font-weight:bold;color:#a71d5d;">_</span><span>, SmItem&gt;::new());
</span><span>    </span><span style="color:#0086b3;">Box</span><span>::into_raw(sm)
</span><span>}
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub unsafe extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_destroy</span><span>(sm: SmPtr) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">_ = unsafe </span><span>{ </span><span style="color:#0086b3;">Box</span><span>::from_raw(sm) };
</span><span>}
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub unsafe extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_insert</span><span>(sm: SmPtr, item: SmItem) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">u64 </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#0086b3;">Some</span><span>(sm) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span>{ sm.</span><span style="color:#62a35c;">as_mut</span><span>() }) </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">0</span><span>;
</span><span>    };
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> handle </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> sm.</span><span style="color:#62a35c;">insert</span><span>(item);
</span><span>    handle.</span><span style="color:#62a35c;">data</span><span>().</span><span style="color:#62a35c;">as_ffi</span><span>()
</span><span>}
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub unsafe extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_contains_key</span><span>(sm: SmPtr, key: </span><span style="font-weight:bold;color:#a71d5d;">u64</span><span>) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#0086b3;">Some</span><span>(sm) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span>{ sm.</span><span style="color:#62a35c;">as_mut</span><span>() }) </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">false</span><span>;
</span><span>    };
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>DefaultKey::from(KeyData::from_ffi(key));
</span><span>    sm.</span><span style="color:#62a35c;">contains_key</span><span>(key)
</span><span>}
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub unsafe extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_get</span><span>(sm: SmPtr, key: </span><span style="font-weight:bold;color:#a71d5d;">u64</span><span>) -&gt; SmItem {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#0086b3;">Some</span><span>(sm) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span>{ sm.</span><span style="color:#62a35c;">as_mut</span><span>() }) </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span>core::ptr::null_mut();
</span><span>    };
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>DefaultKey::from(KeyData::from_ffi(key));
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> ret </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> sm.</span><span style="color:#62a35c;">get</span><span>(key);
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span>ret.</span><span style="color:#62a35c;">unwrap_or</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>core::ptr::null_mut())
</span><span>}
</span><span>
</span><span>#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub unsafe extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">slotmap_remove</span><span>(sm: SmPtr, key: </span><span style="font-weight:bold;color:#a71d5d;">u64</span><span>) -&gt; SmItem {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#0086b3;">Some</span><span>(sm) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>(</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span>{ sm.</span><span style="color:#62a35c;">as_mut</span><span>() }) </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span>core::ptr::null_mut();
</span><span>    };
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>DefaultKey::from(KeyData::from_ffi(key));
</span><span>    sm.</span><span style="color:#62a35c;">remove</span><span>(key).</span><span style="color:#62a35c;">unwrap_or</span><span>(core::ptr::null_mut())
</span><span>}
</span></code></pre>
<p>And after compiling this to a <code>staticlib</code>, do this from the Odin side:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">foreign import</span><span> slotmap </span><span style="color:#183691;">&quot;deps/slotmap/libslotmap.a&quot;
</span><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:c&quot;
</span><span>
</span><span>Slot_Map :: </span><span style="font-weight:bold;color:#a71d5d;">distinct rawptr
</span><span>Sm_Key :: </span><span style="font-weight:bold;color:#a71d5d;">distinct</span><span> c.uint64_t
</span><span>Sm_Item :: ^Group
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">foreign</span><span> slotmap {
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_init</span><span>         :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() -&gt; Slot_Map </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_destroy</span><span>      :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map) </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_insert</span><span>       :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, item: Sm_Item) -&gt; Sm_Key </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_contains_key</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; c.</span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_get</span><span>          :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; Sm_Item </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_remove</span><span>       :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; SmItem </span><span style="color:#0086b3;">---
</span><span>}
</span></code></pre>
<p>Odin's type system allows a <code>rawptr</code> to really be cast to .. any pointer. So here all the types I <em>know</em> are the same, regardless of C's type erasure, are marked with the same alias. Even though, as far as the C ABI is concerned, both <code>Slot_Map</code> and <code>Sm_Item</code> are <code>rawptr</code>s, but <em>I</em> know the difference. Conveniently, <code>Sm_Item</code> can now be easily dereferenced to get the underlying Group without casting.</p>
<p>Having done that, and as much as I am pleased with myself for getting this to work, I do not like that the keys are <code>u64</code>s. They are <em>large</em>: much larger than any number of groups/indices required. Even in the unlikely event of each tile placed forming its own group, there would be a maximum of 126 groups (2 x 63). Eight bits would be enough to have a unique key for every possible group in the game. Something to optimize later, perhaps?</p>
<h2 id="groups-and-game-object-second-draft">Groups, and Game Object - Second Draft</h2>
<p>A group is, simply, two bitboards:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Group :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    tiles:     Bitboard,
</span><span>    liberties: Bitboard,
</span><span>}
</span></code></pre>
<p>Each group keeps track of its location (which hexes it occupies) and its liberties. A group's size and liberty count is calculated by calculating the cardinality of the respective bitboards.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">bb_card</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(bb: Bitboard) -&gt; (ret: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) {
</span><span>    temp := bb &amp; PLAY_AREA
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; </span><span style="color:#0086b3;">7</span><span> {
</span><span>        ret += </span><span style="color:#62a35c;">card</span><span>(temp[i])
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">group_size</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(grp: ^Group) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">int</span><span> {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#62a35c;">bb_card</span><span>(grp.tiles)
</span><span>}
</span><span>
</span><span>
</span><span style="font-weight:bold;color:#795da3;">group_life</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(grp: ^Group) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">int</span><span> {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#62a35c;">bb_card</span><span>(grp.liberties)
</span><span>}
</span></code></pre>
<p>To track groups, two fields are added to the Game Object: one for each player. Additionally, a "Group Map" of sorts might be needed to quickly look up the group any cell belongs to. (This is the initial idea, but keeping all these things in sync seems daunting. There could be a better design that is only revealed with a concrete implementation.)</p>
<p>Revisiting the <code>Game</code> struct from before:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Game :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    board:                 Board,
</span><span>    to_play:               Player,
</span><span>    status:                Status,
</span><span>    last_move:             </span><span style="color:#62a35c;">Maybe</span><span>(Move), </span><span style="font-style:italic;color:#969896;">// &lt;-- I will get to that
</span><span>    guest_hand, host_hand: Hand,
</span><span>    groups_map:            [CELL_COUNT]Sm_Key,
</span><span>    guest_grps, host_grps: Slot_Map,
</span><span>}
</span></code></pre>
<p>Note that the score is not recorded here. As with many aspects of this design, I am currently unsure if it something should be tracked and updated individually with each move, or something calculated from the game state at any given moment.</p>
<p>There is also no history tracking, which needs lists of <code>Move</code>s and past  <code>Board</code>s and <code>Hand</code>s. The slotmap, being currently the only heap allocation, complicates undoing moves trivially, so a new <code>Game</code> object would be constructed from past raw data of boards and games. I decided to ignore history tracking for now.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-style:italic;color:#969896;">// A player&#39;s territory consists of the number of their pieces
</span><span style="font-style:italic;color:#969896;">// on the board minus the number of pieces they didn&#39;t place.
</span><span style="font-weight:bold;color:#795da3;">game_get_score</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(game: ^Game) -&gt; (guest, host: </span><span style="font-weight:bold;color:#a71d5d;">int</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> game.board {
</span><span>        (!</span><span style="color:#62a35c;">tile_is_empty</span><span>(tile)) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> .Controller_Is_Host </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> tile {
</span><span>            host  += </span><span style="color:#0086b3;">1
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>            guest += </span><span style="color:#0086b3;">1
</span><span>        }
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> game.guest_hand {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !</span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> guest -= </span><span style="color:#0086b3;">1
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> game.host_hand {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !</span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> host  -= </span><span style="color:#0086b3;">1
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>Now the game state and its metadata at any given point are neatly encoded, it is time to start thinking about how to make moves, and how to check their legality.</p>
<h2 id="the-game-rules">The Game Rules</h2>
<p>So far, I made no mention of the game's rules, only talking about its physical properties: the tiles, the board, the game zones. But players cannot place Tiles where they choose: here are the rules summarized for your convenience:</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/cl-small-set.png" alt="Full set of Dominions Tiles" /></p>
<h3 id="tiles-1">Tiles</h3>
<ul>
<li>Each <strong>Tile</strong> has a specific set of sides it can connect to, encoded, visually, on the Tile itself.</li>
<li>Each Tile <em>must</em> match its neighboring Tiles in connections. <strong>Connected</strong> sides must match and <strong>Separated</strong> sides must match.</li>
<li>Board edges are considered neutral Separateds.</li>
</ul>
<h3 id="groups">Groups</h3>
<ul>
<li>A <strong>Group</strong> is one or more Tiles of the same color (Controller) that are connected together. Adjacencies on Separated sides do not count.</li>
<li>The <strong>Liberties</strong> of a Group are its Connected sides border empty cells.</li>
<li>If a Group loses its last Liberty, it is captured, and all its tiles are flipped (switched Controller).</li>
</ul>
<h3 id="the-structure">The Structure</h3>
<ul>
<li>The <strong>Structure</strong> is the collective name of all the connections together, in the whole board, <em>regardless of Controller</em>.</li>
<li>Disconnected parts of the Structure are called <strong>Sections</strong>, created as Tiles are placed on Separated adjacencies. A single Section can include multiple Groups (but a Group cannot belong to multiple Sections).</li>
</ul>
<h3 id="placement">Placement</h3>
<p><em>Finally</em></p>
<ul>
<li>Bears repeating: A Tile can only be placed where it matches its neighbours in Connected and Separated sides.</li>
<li>Firstly, the Guest, first player, starts by placing any Tile anywhere.</li>
<li>Afterwards, a Tile can only be placed <em>adjacent to an enemy Tile</em>, with one exception.</li>
<li>A Tile can be placed where it is not adjacent to an enemy Tile <em>if and only if</em> it is extending a Group that is a whole Section.</li>
<li>Suicide is legal. Player may place a Tile so it has no Liberties (by matching its Liberties to enemy Tiles), and is therefore immediately captured.</li>
<li>Lastly, it is illegal to cause <strong>Oscillation</strong>: a Section which has no Liberties. <sup class="footnote-reference" id="fr-5-1"><a href="#fn-5">5</a></sup></li>
<li>A Player may, instead of placing a Tile, pass the turn instead. Or if they have no legal moves, they <em>must</em>.</li>
</ul>
<h3 id="scoring">Scoring</h3>
<ul>
<li>The Game ends when both players pass consecutively.</li>
<li>The winner is the Player with the highest score.</li>
<li>The score is the amount of Tiles controlled on the board <em>minus</em> the Tiles still in Hand.</li>
</ul>
<h2 id="moves-and-game-object-third-draft">Moves, and Game Object - Third Draft</h2>
<p>Back to code. As a refresher, here is <code>Move</code>:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Move :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    hex:  Hex,
</span><span>    tile: Tile,
</span><span>}
</span></code></pre>
<p>That is all a <code>Move</code> is: the player whose turn it is (as tracked by <code>Game</code>) places a <code>Tile</code> from their hand into a <code>Hex</code>, and from there follows that groups get updated and tiles get flipped and game progresses.</p>
<p>But as a player may (or may have to) pass the turn, and as the game ends with two successive passes, <code>last_move</code> is registered in <code>Game</code> to track whether the game is about to end.<sup class="footnote-reference" id="fr-6-1"><a href="#fn-6">6</a></sup></p>
<p>To play the game, <code>Game</code> needs to have the following:</p>
<ul>
<li>A way to make the move</li>
<li>A way to query if a move is legal</li>
<li>A way to query the list of legal moves</li>
</ul>
<p>Perhaps the most straightforward way to do it is to have <code>game_make_move</code> do <em>all</em> the work. It updates the game state, naturally, but also (based on said game state) update an embedded list of legal moves in <code>Game</code> itself. And then to check if a move is legal, simply query the embedded list of moves. Here is what <code>Game</code>, and the skeleton of <code>game_make_move</code>, look like now:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Game :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    board:                 Board,
</span><span>    to_play:               Player,
</span><span>    status:                Status,
</span><span>    last_move:             </span><span style="color:#62a35c;">Maybe</span><span>(Move),
</span><span>
</span><span>    guest_hand, host_hand: Hand,
</span><span>
</span><span>    groups_map:            [CELL_COUNT]SmKey,
</span><span>    guest_grps, host_grps: SlotMap,
</span><span>
</span><span>    legal_moves:           [</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Move,
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">game_make_move</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(game: ^Game, try: </span><span style="color:#62a35c;">Maybe</span><span>(Move)) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> {
</span><span>    (game.status == .Ongoing) </span><span style="font-weight:bold;color:#a71d5d;">or_return </span><span style="font-style:italic;color:#969896;">// Game is over.
</span><span>    move, not_pass := try.?
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// legal move check
</span><span>    (!not_pass ||
</span><span>        slice.</span><span style="color:#62a35c;">contains</span><span>(game.legal_moves[:], move) ||
</span><span>        </span><span style="color:#62a35c;">board_is_empty</span><span>(&amp;game.board)) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer if</span><span> game.status == .Ongoing {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> game.to_play {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Guest: game.to_play = .Host
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Host:  game.to_play = .Guest
</span><span>        }
</span><span>        game.last_move = move
</span><span>        </span><span style="color:#62a35c;">game_regen_legal_moves</span><span>(game)
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !not_pass {     </span><span style="font-style:italic;color:#969896;">// Pass
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> game.last_move == </span><span style="color:#0086b3;">nil</span><span> {     </span><span style="font-style:italic;color:#969896;">// Game ends
</span><span>            guest, host := </span><span style="color:#62a35c;">game_get_score</span><span>(game)
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> guest &gt; host </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> game.status = .Guest_Win
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span> guest &lt; host </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> game.status = .Host_Win
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">else do</span><span> game.status = .Tie
</span><span>        }
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">true
</span><span>    }
</span><span>
</span><span>    active_hand: ^Hand
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> game.to_play {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Guest: active_hand = &amp;game.guest_hand
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Host:  active_hand = &amp;game.host_hand
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Make move. Already known to be legal!!
</span><span>    hand_tile, removed := </span><span style="color:#62a35c;">hand_remove_tile</span><span>(active_hand, move.tile)
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(removed) </span><span style="font-style:italic;color:#969896;">// but verify
</span><span>    game.board[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] = hand_tile
</span><span>    move.tile = hand_tile </span><span style="font-style:italic;color:#969896;">// probably superfluous.
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// TODO: update game state
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">true
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">game_regen_legal_moves</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(game: ^Game) {
</span><span>    </span><span style="color:#62a35c;">clear</span><span>(&amp;game.legal_moves)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// TODO: build them again
</span><span>}
</span></code></pre>
<p>The two <code>TODO</code>s left are probably the meat of this whole engine. It is clearer to write them out in steps, in English, before encoding them into code.</p>
<h2 id="updating-the-game-state">Updating the Game State</h2>
<p>The key observation, I think, is that the game state change starts from the where the last move is played. No need for a global search process, but only the exact Hex being played and the surrounding groups.</p>
<h3 id="group-section-init"><code>group_section_init</code></h3>
<p>The simplest, and shortest, game state change that is not a Pass, is a Tile that starts its own Section. This happens in two occasions: the first move, and whenever a Tile is only adjacent to other tiles via its Separated sides. This Tile by definition also starts a new Group. This procedure assumes it is only called when a move is legal.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">group_section_init</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(move: Move, game: ^Game) -&gt; (ret: Group, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> = </span><span style="color:#0086b3;">true</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// Check that all Connected sides connect to empty tiles.
</span><span>    </span><span style="font-style:italic;color:#969896;">// AND find Liberties
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> move.tile &amp; CONNECTION_FLAGS {
</span><span>        neighbor := move.hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>
</span><span>        t, in_bounds := </span><span style="color:#62a35c;">board_get_tile</span><span>(&amp;game.board, neighbor)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> in_bounds {
</span><span>            </span><span style="color:#62a35c;">tile_is_empty</span><span>(t^) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>            </span><span style="color:#62a35c;">bb_set_bit</span><span>(&amp;ret.liberties, </span><span style="color:#62a35c;">hex_to_index</span><span>(neighbor))
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#62a35c;">bb_set_bit</span><span>(&amp;ret.tiles, </span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex))
</span><span>    </span><span style="font-style:italic;color:#969896;">// CELL_COUNT is where the Extended flag is.
</span><span>    </span><span style="color:#62a35c;">bb_set_bit_unchecked</span><span>(&amp;ret.liberties, CELL_COUNT)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>And in <code>game_make_move</code> :</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">if</span><span> grp, ok := </span><span style="color:#62a35c;">group_section_init</span><span>(move, game); ok {
</span><span>    grp := </span><span style="color:#62a35c;">new_clone</span><span>(grp)
</span><span>    key := </span><span style="color:#62a35c;">slotmap_insert</span><span>(game.host_grps, grp)
</span><span>    game.groups_map[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] = key
</span><span>}
</span></code></pre>
<h3 id="group-attach-to-friendlies"><code>group_attach_to_friendlies</code></h3>
<p>The second easiest to deal with is a Tile that only connects to Groups of its own color. But there are a few variations</p>
<ul>
<li><em>Extension</em>: The Tile may only extend one Group</li>
<li><em>Merge</em>: The Tile may merge two friendly Groups into one.</li>
<li><em>Suicide</em>: The Tile may consume the remaining Liberties of the Group(s) it connects to, Suiciding the whole Group. In which case the newly formed Group is captured (flipped) as a whole, and merged with the surrounding enemy Group(s).</li>
</ul>
<p>The last case is interesting. Note that Move legality is checked earlier, so on principle, it is <em>known</em> that the newly formed enemy Group has at least one Liberty left.</p>
<p>A funny observation here is that it is impossible for a Tile that <em>only connects to friendlies</em> to Capture an enemy Group, but it is entirely possible that is causes its own Group to be immediately captured.</p>
<p>An easy check to whether this move is a Suicide is to check whether the new Tile has any Liberties of its own. For example: if it has 2 Connections and is connected to a friendly Group from only one side of the two, and the other Connection is to an empty cell, then it is obviously <em>not</em> a Suicide.</p>
<p>Ergo, the procedure for extension or merging is as follows. It turned <em>way</em> longer than I expected.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">group_extend_or_merge</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(move: Move, game: ^Game) -&gt; (ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> = </span><span style="color:#0086b3;">true</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// Bug tracker
</span><span>    tile_liberties_count := </span><span style="color:#62a35c;">card</span><span>(move.tile &amp; CONNECTION_FLAGS)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Friendliness tracker
</span><span>    tile_control := move.tile &amp; {.Controller_Is_Host}
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Scratchpad: Found Groups
</span><span>    nbr_friend_grps: [</span><span style="color:#0086b3;">6</span><span>]Sm_Key
</span><span>    nfg_cursor:      </span><span style="font-weight:bold;color:#a71d5d;">int
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Scratchpad: New Liberties
</span><span>    new_libs:    [</span><span style="color:#0086b3;">6</span><span>]Hex
</span><span>    libs_cursor: </span><span style="font-weight:bold;color:#a71d5d;">int
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> move.tile &amp; CONNECTION_FLAGS {
</span><span>        neighbor := move.hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>        nbr_tile := </span><span style="color:#62a35c;">board_get_tile</span><span>(&amp;game.board, neighbor) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(nbr_tile^) {
</span><span>            new_libs[libs_cursor] = neighbor
</span><span>            libs_cursor += </span><span style="color:#0086b3;">1
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span> nbr_tile^ &amp; {.Controller_Is_Host} == tile_control {
</span><span>            </span><span style="font-style:italic;color:#969896;">// Same Controller
</span><span>            tile_liberties_count -= </span><span style="color:#0086b3;">1
</span><span>
</span><span>            </span><span style="font-style:italic;color:#969896;">// record Group of neighbor tile.
</span><span>            key := game.groups_map[</span><span style="color:#62a35c;">hex_to_index</span><span>(neighbor)]
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(nbr_friend_grps[:], key) {
</span><span>                nbr_friend_grps[nfg_cursor] = key
</span><span>                nfg_cursor += </span><span style="color:#0086b3;">1
</span><span>            }
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>            </span><span style="font-style:italic;color:#969896;">// Different Controller
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">false
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(
</span><span>        tile_liberties_count &gt;= </span><span style="color:#0086b3;">0</span><span>,
</span><span>        </span><span style="color:#183691;">&quot;if this is broken there is a legality bug&quot;
</span><span>    )
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(
</span><span>        nfg_cursor &gt; </span><span style="color:#0086b3;">0</span><span>,
</span><span>        </span><span style="color:#183691;">&quot;This proc should not be called with no friendly neighbors&quot;
</span><span>        )
</span><span>    </span><span style="font-style:italic;color:#969896;">// and if this is false then this might be a Suicide
</span><span>    (tile_liberties_count &gt; </span><span style="color:#0086b3;">0</span><span>) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Are we the Baddies?
</span><span>    friendly_grps: Slot_Map
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> tile_control == {} {
</span><span>        friendly_grps = game.guest_grps
</span><span>    } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>        friendly_grps = game.host_grps
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Identify first group
</span><span>    blessed_key := nbr_friend_grps[</span><span style="color:#0086b3;">0</span><span>]
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, blessed_key))
</span><span>    blessed_grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(friendly_grps, blessed_key)
</span><span>    </span><span style="color:#62a35c;">bb_set_bit</span><span>(&amp;blessed_grp.tiles, </span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex))
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Merge other groups with first group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">1</span><span> ..&lt; nfg_cursor {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, nbr_friend_grps[i]))
</span><span>        grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, nbr_friend_grps[i])
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(grp)
</span><span>
</span><span>        blessed_grp.tiles |= grp.tiles
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// Only if both Groups are extendable is the new one extendable
</span><span>        play_area := PLAY_AREA &amp; (blessed_grp.liberties | grp.liberties)
</span><span>        data_area := DATA_AREA &amp; (blessed_grp.liberties &amp; grp.liberties)
</span><span>        blessed_grp.liberties = play_area | data_area
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update liberties
</span><span>    </span><span style="color:#62a35c;">bb_unset_bit</span><span>(&amp;blessed_grp.liberties, </span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex))
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> l </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; libs_cursor {
</span><span>        </span><span style="color:#62a35c;">bb_set_bit</span><span>(&amp;blessed_grp.liberties, </span><span style="color:#62a35c;">hex_to_index</span><span>(new_libs[l]))
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update the groupmap
</span><span>    bbi := </span><span style="color:#62a35c;">bb_make_iter</span><span>(blessed_grp.tiles)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> _, idx </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#62a35c;">bb_iter</span><span>(&amp;bbi) {
</span><span>        game.groups_map[idx] = blessed_key
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// this should be all.
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>Now, what to do if it <em>is</em> a potential suicide? First of all, it is not possible to know whether it is a suicide or not without doing everything already done in <code>group_extend_or_merge</code> anyway. If it were a Suicide, the final, coalesced Group would have no Liberties, and therefore it would be an easy decision to simply flip its Controller and swap its allegiance.</p>
<p>The problem lies in how to merge it with its capturing Group(s). It needs to be merged to maintain an accurate count of Liberties, as the count of Liberties is clearly being used to test whether it needs to be captured or not!! (Not in <em>this</em> move. but in subsequent ones.)</p>
<p>The naïve approach is to iterate over every Tile member of the Group and every Connection of said Tile, and compile a list of opponent-controlled neighbors, then check the Group membership of <em>those</em> Tiles, (similarly to how <code>nbr_friend_grps</code> is used,) then do the merging routine again, but this time for the opponent.</p>
<p>The <em>other</em> naïve approach is to add a third <code>Bitboard</code> to <code>Group</code> to track its surrounding enemies and just iterate over those.</p>
<p>Both solutions bother me for different reasons. The first seems like a time and CPU cycle waste (as I am already iterating over the same Tile's flags multiple times ..), and the second seems adds an extra knob to keep track of.</p>
<h2 id="rethinking-groups">Rethinking Groups</h2>
<p>One idea to explore is to change <code>Group</code>'s representation entirely, away from Bitboards. (Yes I spent a lot of time talking about Bitboards, and they're really cool, but hear me out). Throughout the program, the state of the game has been tracked through a number of <code>[CELL_COUNT]</code> arrays, of variable things, with trivial conversion from a human-readable <code>Hex</code> to an index within these arrays. So what's another <code>[CELL_COUNT]</code> array? But what would it be an array <em>of</em>?</p>
<p>Currently, as far as a Group is concerned, a location can be one of three states: Either a member Tile, a Liberty, or an enemy Connection. That is an enum! More things can be added to it later as needed.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Hex_State :: </span><span style="font-weight:bold;color:#a71d5d;">enum u8</span><span> {
</span><span>    Empty            = </span><span style="color:#0086b3;">0b000</span><span>, </span><span style="font-style:italic;color:#969896;">// numbers chosen for a reason
</span><span>    Liberty          = </span><span style="color:#0086b3;">0b001</span><span>,
</span><span>    Enemy_Connection = </span><span style="color:#0086b3;">0b011</span><span>,
</span><span>    Member_Tile      = </span><span style="color:#0086b3;">0b111</span><span>,
</span><span>}
</span></code></pre>
<p>And this how the <code>Group</code> using this enum would look like:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Rethought_Group :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    state:      [CELL_COUNT]Hex_State,
</span><span>    extendable: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>, </span><span style="font-style:italic;color:#969896;">// sadly no clean niche to hide that
</span><span>}
</span></code></pre>
<p>Much cleaner! Surprisingly, Odin allows bitwise OR over enumerations.<sup class="footnote-reference" id="fr-7-1"><a href="#fn-7">7</a></sup> If the resulting value has no tag assigned, it becomes a <code>BAD_ENUM_VALUE</code> and may potentially wreck the program. But if the numbers are assigned appropriately, it can be made to always have a valid value.</p>
<p>Thinking through this, it is clear that <code>.Empty</code> with any other tag should be, well, that other tag. <code>.Liberty</code>, being essentially an empty cell as well, with any of the other two tags should produce the other tag. <code>.Member_Tile</code> and <code>.Enemy_Connection</code> overlap when capturing groups, so Enemies should be converted to Members. Here is the printed <code>OR</code> table:</p>
<pre style="background-color:#ffffff;color:#323232;"><code><span>          Empty   Liberty   Enemy   Member
</span><span>
</span><span>Empty     Empty   Liberty   Enemy   Member
</span><span>Liberty ------&gt;   Liberty   Enemy   Member
</span><span>Enemy   ----------------&gt;   Enemy   Member
</span><span>Member  ------------------------&gt;   Member
</span></code></pre>
<p>Great. Looks good to me. Let's roll with it. This is how <code>Group</code> works now. Should I need more states I shall think of other clever numbers to use. Then follow the compiler's errors about missing fields and correct those as needed.</p>
<p>Compiler driven development !!</p>
<h2 id="back-to-updating-game-state">Back to Updating Game State</h2>
<h3 id="back-to-group-attach-to-friendlies">Back to <code>group_attach_to_friendlies</code></h3>
<p>This above change makes the merging process much simpler. It also allowed me to delete the entire <code>bitboard.odin</code> file! Following the compiler's errors leads me to this version of <code>group_extend_or_merge</code>:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">group_extend_or_merge</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(move: Move, game: ^Game) -&gt; (ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> = </span><span style="color:#0086b3;">true</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// ----- snip: same as before, for now.
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Identify first group
</span><span>    blessed_key := nbr_friend_grps[</span><span style="color:#0086b3;">0</span><span>]
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, blessed_key))
</span><span>    blessed_grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(friendly_grps, blessed_key)
</span><span>    blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] = .Member_Tile
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Merge other groups with first group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">1</span><span> ..&lt; nfg_cursor {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, nbr_friend_grps[i]))
</span><span>        grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, nbr_friend_grps[i])
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(grp)
</span><span>
</span><span>        blessed_grp.state |= grp.state
</span><span>        blessed_grp.extendable &amp;= grp.extendable
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update liberties
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> l </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; libs_cursor {
</span><span>        blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(new_libs[l])] |= .Liberty
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update the groupmap
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> slot, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> slot == .Member_Tile </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> game.groups_map[idx] = blessed_key
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>Now, merging groups membership and liberties also merges their enemy connections as well. No additional bookkeeping! The check for potential Suicide earlier can now be removed, and writing this (larger and larger) procedure can continue:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// ----- snip: same as before + declaring pointers to enemy groups
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update liberties
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> l </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; libs_cursor {
</span><span>        blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(new_libs[l])] |= .Liberty
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> tile_liberties_count == </span><span style="color:#0086b3;">0      </span><span style="font-style:italic;color:#969896;">// Potential Suicide
</span><span>       &amp;&amp; </span><span style="color:#62a35c;">group_life</span><span>(blessed_grp) == </span><span style="color:#0086b3;">0 </span><span style="font-style:italic;color:#969896;">// Definite Suicide
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#969896;">// no insertion into the enemy slotmap .. there is merging to be done!
</span><span>        cursed_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, blessed_key)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(cursed_grp)
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// Scratchpad
</span><span>        nbr_enemy_grps := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Sm_Key)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(nbr_enemy_grps)
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> loc, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> cursed_grp.state {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">#partial switch</span><span> loc {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Member_Tile:
</span><span>                </span><span style="color:#62a35c;">tile_flip</span><span>(&amp;game.board[idx])
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Enemy_Connection:
</span><span>                key := game.groups_map[idx]
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(nbr_enemy_grps[:], key) {
</span><span>                    </span><span style="color:#62a35c;">append</span><span>(&amp;nbr_enemy_grps, key)
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        </span><span style="font-style:italic;color:#969896;">// == same steps as before
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">len</span><span>(nbr_enemy_grps) &gt; </span><span style="color:#0086b3;">0</span><span>) </span><span style="font-style:italic;color:#969896;">// or there is Oscillation
</span><span>        blessed_key = nbr_enemy_grps[</span><span style="color:#0086b3;">0</span><span>]
</span><span>
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, blessed_key))
</span><span>        blessed_grp = </span><span style="color:#62a35c;">slotmap_get</span><span>(enemy_grps, blessed_key)
</span><span>
</span><span>        blessed_grp.state |= cursed_grp.state
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">1</span><span> ..&lt; </span><span style="color:#62a35c;">len</span><span>(nbr_enemy_grps) {
</span><span>            </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, nbr_enemy_grps[i]))
</span><span>            grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(enemy_grps, nbr_enemy_grps[i])
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(grp)
</span><span>
</span><span>            blessed_grp.state |= grp.state
</span><span>        }
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// check if blessed_grp is extendable
</span><span>        extendable := </span><span style="color:#0086b3;">true
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> loc </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> loc == .Enemy_Connection {
</span><span>                extendable = </span><span style="color:#0086b3;">false
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>            }
</span><span>        }
</span><span>        blessed_grp.extendable = extendable
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update the groupmap
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> slot, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> slot == .Member_Tile </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> game.groups_map[idx] = blessed_key
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>Change the procedure's name to <code>group_attach_to_friendlies</code>, and <em>now</em> it is done. All this merging logic should really be refactored and <code>DRY</code>'d, but I will let it be for now. This one procedure end up about 130 lines of code.</p>
<h3 id="group-attach-to-enemies"><code>group_attach_to_enemies</code></h3>
<p>Similarly to attaching to friendlies, this move can either be a nothing, a capture, or a suicide. The logic of the <code>friendlies</code> procedure might need to be repeated in this one. And the checks done and the data collected would also need to be repeated.</p>
<p>So why separate it at all? The idea was it would simplify handling, but it does not seem to do that. So, rethinking the move handling, allow me to try summarising the logic that <em>actually</em> needs to be done (this was revised in tandem with writing the code in the next section):</p>
<ol>
<li>Create these trackers:
<ol>
<li>Liberties of the newly placed tile,</li>
<li>Neighboring, connected Friendlies (tracking Groups), and</li>
<li>Neighboring, connected Enemies (tracking locations).</li>
</ol>
</li>
<li>Iterate over all Connected Sides of the newly placed tile, and fill in the trackers as needed,</li>
<li>For every Friendly connected Group, merge them together. (If none are connected, the Tile starts its own Group with marked Liberties and Enemy neighbors.) Mark this group as "Blessed".</li>
<li>Iterate over neighboring Enemy Groups, if any have a Liberty count of 0: <sup class="footnote-reference" id="fr-8-1"><a href="#fn-8">8</a></sup>
<ol>
<li>They are flipped and merged with the Blessed Group.</li>
<li>Iterate over connections of the Blessed Group, and merge with it any friendly Groups found.</li>
<li>Move is over. (This is because legal moves are already screened, or a check for Oscillation would be needed.)</li>
</ol>
</li>
<li>The Blessed Group is checked for Liberty count. If it is 0, it is captured (flipped) and merged with its surrounding Enemy Groups.</li>
<li>Done</li>
</ol>
<p>Note that I am assuming here that this is not a recursive operation. Here is the assumption: A new Tile placement that has no liberties <em>but</em> takes away the last liberty of an enemy Group captures it. There is no need to check if the surrounding friendly Groups (that surrounded the surrounding Enemy Groups) would also have no Liberties, because if they had no Liberties they would not exist! A lot of weight is placed right now on the correctness of <code>game_regen_legal_moves</code>, which is still delayed for later.</p>
<h3 id="game-update-state-inner-second-draft"><code>game_update_state_inner</code> - Second Draft</h3>
<p>A monstrous 230-ish lines of code which could really use some refactoring. This drags on but I made my best to comment my thoughts throughout. Written without Tests, as I don't actually know <em>how</em> to test this yet</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">game_update_state_inner</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(move: Move, game: ^Game) {
</span><span>    </span><span style="font-style:italic;color:#969896;">// Bug tracker
</span><span>    tile_liberties := </span><span style="color:#62a35c;">card</span><span>(move.tile &amp; CONNECTION_FLAGS)
</span><span>    tile_liberties_countdown := tile_liberties
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Friendliness tracker
</span><span>    tile_control := move.tile &amp; {.Controller_Is_Host}
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Scratchpad: Found friendly Groups
</span><span>    nbr_friend_grps: [</span><span style="color:#0086b3;">6</span><span>]Sm_Key
</span><span>    nfg_counter:     </span><span style="font-weight:bold;color:#a71d5d;">uint
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Scratchpad: Found Enemy Groups
</span><span>    nbr_enemy_tiles: [</span><span style="color:#0086b3;">6</span><span>]Hex
</span><span>    net_counter:     </span><span style="font-weight:bold;color:#a71d5d;">uint
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// Scratchpad: New Liberties
</span><span>    new_libs:     [</span><span style="color:#0086b3;">6</span><span>]Hex
</span><span>    libs_counter: </span><span style="font-weight:bold;color:#a71d5d;">uint
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> move.tile &amp; CONNECTION_FLAGS {
</span><span>        neighbor := move.hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>        nbr_tile := </span><span style="color:#62a35c;">board_get_tile</span><span>(&amp;game.board, neighbor) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(nbr_tile^) {
</span><span>            new_libs[libs_counter] = neighbor
</span><span>            libs_counter += </span><span style="color:#0086b3;">1
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span> nbr_tile^ &amp; {.Controller_Is_Host} == tile_control {
</span><span>            </span><span style="font-style:italic;color:#969896;">// Same Controller
</span><span>            tile_liberties_countdown -= </span><span style="color:#0086b3;">1
</span><span>
</span><span>            </span><span style="font-style:italic;color:#969896;">// record Group of neighbor tile.
</span><span>            key := game.groups_map[</span><span style="color:#62a35c;">hex_to_index</span><span>(neighbor)]
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(nbr_friend_grps[:], key) {
</span><span>                nbr_friend_grps[nfg_counter] = key
</span><span>                nfg_counter += </span><span style="color:#0086b3;">1
</span><span>            }
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>            </span><span style="font-style:italic;color:#969896;">// Different Controller
</span><span>            tile_liberties_countdown -= </span><span style="color:#0086b3;">1
</span><span>
</span><span>            nbr_enemy_tiles[net_counter] = neighbor
</span><span>            net_counter += </span><span style="color:#0086b3;">1
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(
</span><span>        tile_liberties_countdown &gt;= </span><span style="color:#0086b3;">0</span><span>,
</span><span>        </span><span style="color:#183691;">&quot;if this is broken there is a legality bug&quot;
</span><span>    )
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Are we the Baddies?
</span><span>    friendly_grps, enemy_grps: Slot_Map
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> tile_control == {} {
</span><span>        </span><span style="font-style:italic;color:#969896;">// Guest Controller
</span><span>        friendly_grps = game.guest_grps
</span><span>        enemy_grps = game.host_grps
</span><span>    } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>        </span><span style="font-style:italic;color:#969896;">// Host Controller
</span><span>        friendly_grps = game.host_grps
</span><span>        enemy_grps = game.guest_grps
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// The placed Tile&#39;s Group
</span><span>    blessed_key: Sm_Key
</span><span>    blessed_grp: Sm_Item
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> nfg_counter == </span><span style="color:#0086b3;">0</span><span> {
</span><span>        blessed_grp = </span><span style="color:#62a35c;">new</span><span>(Group)
</span><span>        blessed_key = </span><span style="color:#62a35c;">slotmap_insert</span><span>(friendly_grps, blessed_grp)
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> net_counter == </span><span style="color:#0086b3;">0</span><span> {
</span><span>            blessed_grp.extendable = </span><span style="color:#0086b3;">true
</span><span>        }
</span><span>    } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>        blessed_key = nbr_friend_grps[</span><span style="color:#0086b3;">0</span><span>]
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(
</span><span>            </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, blessed_key),
</span><span>            </span><span style="color:#183691;">&quot;Friendly slotmap does not have friendly Key&quot;</span><span>,
</span><span>        )
</span><span>        blessed_grp = </span><span style="color:#62a35c;">slotmap_get</span><span>(friendly_grps, blessed_key)
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// == Merge other groups with blessed group
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">1</span><span> ..&lt; nfg_counter {
</span><span>            </span><span style="color:#62a35c;">assert</span><span>(
</span><span>                </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, nbr_friend_grps[i]),
</span><span>                </span><span style="color:#183691;">&quot;Friendly slotmap does not have friendly Key&quot;</span><span>,
</span><span>            )
</span><span>            temp_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, nbr_friend_grps[i])
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(temp_grp)
</span><span>
</span><span>            blessed_grp.state |= temp_grp.state
</span><span>            blessed_grp.extendable &amp;= temp_grp.extendable
</span><span>        }
</span><span>    }
</span><span>    blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] |= .Member_Tile
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> {
</span><span>        </span><span style="font-style:italic;color:#969896;">// == Update the groupmap
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> slot, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> slot == .Member_Tile </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> game.groups_map[idx] = blessed_key
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update liberties
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; libs_counter {
</span><span>        blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(new_libs[i])] |= .Liberty
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Update Enemy neighbors for blessed group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; net_counter {
</span><span>        blessed_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(nbr_enemy_tiles[i])] |= .Enemy_Connection
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == register surrounding Enemy Groups of blessed Group
</span><span>    surrounding_enemy_grps := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Sm_Key)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(surrounding_enemy_grps)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> slot, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>        (slot == .Enemy_Connection) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>        key := game.groups_map[idx]
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(surrounding_enemy_grps[:], key) {
</span><span>            </span><span style="color:#62a35c;">append</span><span>(&amp;surrounding_enemy_grps, key)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == if there are no surrounding enemy groups there is nothing to do
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">len</span><span>(surrounding_enemy_grps) == </span><span style="color:#0086b3;">0</span><span> {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(
</span><span>            </span><span style="color:#62a35c;">group_life</span><span>(blessed_grp) &gt; </span><span style="color:#0086b3;">0</span><span>,
</span><span>            </span><span style="color:#183691;">&quot;newly formed groups must have liberties or enemy connections&quot;</span><span>,
</span><span>        )
</span><span>        blessed_grp.extendable = </span><span style="color:#0086b3;">true
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == these are the friendly groups that surround the dead enemy groups.
</span><span>    level_2_surrounding_friendlies := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Sm_Key)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(level_2_surrounding_friendlies)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == go over surrounding enemy groups to see if they&#39;re dead.
</span><span>    capture_occurance := </span><span style="color:#0086b3;">false
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> surrounding_enemy_grps {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(
</span><span>            </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, key),
</span><span>            </span><span style="color:#183691;">&quot;Enemy slotmap does not have enemy Key&quot;
</span><span>        )
</span><span>        temp_grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(enemy_grps, key)
</span><span>        temp_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] |= .Enemy_Connection </span><span style="font-style:italic;color:#969896;">// spoiler: there be bugs
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// Enemy Group is dead
</span><span>        (</span><span style="color:#62a35c;">group_life</span><span>(temp_grp) == </span><span style="color:#0086b3;">0</span><span>) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>        capture_occurance = </span><span style="color:#0086b3;">true
</span><span>
</span><span>        cursed_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(enemy_grps, key)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(cursed_grp)
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> slot, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> cursed_grp.state {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">#partial switch</span><span> slot {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Member_Tile:
</span><span>                </span><span style="color:#62a35c;">tile_flip</span><span>(&amp;game.board[idx])
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Enemy_Connection:
</span><span>                key := game.groups_map[idx]
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(level_2_surrounding_friendlies[:], key) {
</span><span>                    </span><span style="color:#62a35c;">append</span><span>(&amp;level_2_surrounding_friendlies, key)
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="font-style:italic;color:#969896;">// CAPTURE
</span><span>        blessed_grp.state      |= cursed_grp.state
</span><span>        blessed_grp.extendable &amp;= cursed_grp.extendable
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == merge level 2 surrounding friendlies into blessed group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> level_2_surrounding_friendlies {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, key))
</span><span>        temp_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, key)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(temp_grp)
</span><span>
</span><span>        blessed_grp.state |= temp_grp.state
</span><span>        blessed_grp.extendable &amp;= temp_grp.extendable
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == if there is a capture, it is done.
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> capture_occurance </span><span style="font-weight:bold;color:#a71d5d;">do return
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == if blessed group&#39;s liberties larger than 0, it is done capturing
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">group_life</span><span>(blessed_grp) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do return
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Now the blessed group has converted.
</span><span>
</span><span>    cursed_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(friendly_grps, blessed_key)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(cursed_grp)
</span><span>
</span><span>    new_family := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Sm_Key)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(new_family)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> loc, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">#partial switch</span><span> loc {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Member_Tile:
</span><span>            </span><span style="color:#62a35c;">tile_flip</span><span>(&amp;game.board[idx])
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Enemy_Connection:
</span><span>            key := game.groups_map[idx]
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !slice.</span><span style="color:#62a35c;">contains</span><span>(new_family[:], key) {
</span><span>                </span><span style="color:#62a35c;">append</span><span>(&amp;new_family, key)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">len</span><span>(new_family) &gt; </span><span style="color:#0086b3;">0</span><span>, </span><span style="color:#183691;">&quot;Oscillation&quot;</span><span>)
</span><span>
</span><span>    blessed_key = new_family[</span><span style="color:#0086b3;">0</span><span>]
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(
</span><span>        </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, blessed_key),
</span><span>        </span><span style="color:#183691;">&quot;Enemy key is not in enemy map&quot;
</span><span>    )
</span><span>
</span><span>    blessed_grp = </span><span style="color:#62a35c;">slotmap_get</span><span>(enemy_grps, blessed_key)
</span><span>    blessed_grp.state |= cursed_grp.state
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">1</span><span> ..&lt; </span><span style="color:#62a35c;">len</span><span>(new_family) {
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(</span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, new_family[i]))
</span><span>        temp_grp := </span><span style="color:#62a35c;">slotmap_remove</span><span>(enemy_grps, new_family[i])
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">free</span><span>(temp_grp)
</span><span>
</span><span>        blessed_grp.state |= temp_grp.state
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// check if new blessed group is extendable
</span><span>    extendable := </span><span style="color:#0086b3;">true
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> loc </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> blessed_grp.state {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> loc == .Enemy_Connection {
</span><span>            extendable = </span><span style="color:#0086b3;">false
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>        }
</span><span>    }
</span><span>    blessed_grp.extendable = extendable
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>I attempted refactoring some of it out but I am not sure the result is necessarily better. I also used the <code>core:container/small_array</code> library (from the Odin core lib) to smooth some of the logic.</p>
<h2 id="game-regen-legal-moves"><code>game_regen_legal_moves</code></h2>
<p>This is the current state of this procedure, which a lot is riding on:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">@(private)
</span><span style="font-weight:bold;color:#795da3;">game_regen_legal_moves</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(game: ^Game) {
</span><span>    </span><span style="color:#62a35c;">clear</span><span>(&amp;game.legal_moves)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// todo: build them again
</span><span>}
</span></code></pre>
<p>This is perhaps an easier problem than it presented to me at first. The rules have a harsh restriction to placement: any Tile placed MUST be placed next to an enemy Tile, unless it extends a Group which makes its own Section (which is already being tracked by the <code>extendable</code> field in <code>Group</code>. Assuming the logic, of course, is correct.)</p>
<p>The naïve, crude approach is as follows: Iterate over every empty <code>Hex</code>, and if it has an enemy neighbor, <em>or</em> if it has a friendly neighbor that is part of an extendable Group <em>and</em> it is that Group's liberty, add it to the candidates. Then for each <code>Hex</code> of the candidates, iterate over the friendly <code>Hand</code>, and add a <code>Move</code> where the <code>Tile</code> fits. There might be a more efficient way but this will do for now.</p>
<p>(Yes this does not take Oscillation into account, yet?)</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">game_regen_legal_moves</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(game: ^Game) {
</span><span>    </span><span style="color:#62a35c;">clear</span><span>(&amp;game.legal_moves)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// == Are we the Baddies?
</span><span>    friendly_grps: Slot_Map
</span><span>    friendly_hand: ^Hand
</span><span>    enemy_grps: Slot_Map
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> game.to_play {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Guest:
</span><span>        friendly_grps = game.guest_grps
</span><span>        friendly_hand = &amp;game.guest_hand
</span><span>        enemy_grps    = game.host_grps
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Host:
</span><span>        friendly_grps = game.host_grps
</span><span>        friendly_hand = &amp;game.host_hand
</span><span>        enemy_grps    = game.guest_grps
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// get the hexes allowed to be played in
</span><span>    playable_hexes := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Hex)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(playable_hexes)
</span><span>
</span><span>    outer: </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> game.groups_map {
</span><span>        </span><span style="font-style:italic;color:#969896;">// Hex must be empty. Hope Slotmap does not give a Key of 0.
</span><span>        (key == </span><span style="color:#0086b3;">0</span><span>) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>
</span><span>        hex := </span><span style="color:#62a35c;">hex_from_index</span><span>(idx)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> CONNECTION_FLAGS {
</span><span>            nbr_hex := hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>            nbr_idx := </span><span style="color:#62a35c;">hex_to_index</span><span>(nbr_hex) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>
</span><span>            nbr_key := game.groups_map[nbr_idx]
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> nbr_key == </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do continue
</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, nbr_key) {
</span><span>                </span><span style="color:#62a35c;">append</span><span>(&amp;playable_hexes, hex)
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">continue</span><span> outer
</span><span>            } </span><span style="font-weight:bold;color:#a71d5d;">else if </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, nbr_key) {
</span><span>                grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(friendly_grps, nbr_key)
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> grp.extendable &amp;&amp; grp.state[idx] == .Liberty {
</span><span>                    </span><span style="color:#62a35c;">append</span><span>(&amp;playable_hexes, hex)
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">continue</span><span> outer
</span><span>                }
</span><span>            } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>                </span><span style="font-style:italic;color:#969896;">// This is essentially an assert.
</span><span>                </span><span style="color:#62a35c;">panic</span><span>(</span><span style="color:#183691;">&quot;key is not 0, is not in friendly groups, not in enemy groups, ??&quot;</span><span>)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// fill Tiles to go with found hexes.
</span><span>    candidate_moves := </span><span style="color:#62a35c;">make</span><span>([</span><span style="font-weight:bold;color:#a71d5d;">dynamic</span><span>]Move)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">delete</span><span>(candidate_moves)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> hex </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> playable_hexes {
</span><span>        idx := </span><span style="color:#62a35c;">hex_to_index</span><span>(hex)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> friendly_hand {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) </span><span style="font-weight:bold;color:#a71d5d;">do continue
</span><span>
</span><span>            score := </span><span style="color:#0086b3;">0 </span><span style="font-style:italic;color:#969896;">// if score is 6, tile is playable.
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">defer if</span><span> score == </span><span style="color:#0086b3;">6 </span><span style="font-weight:bold;color:#a71d5d;">do </span><span style="color:#62a35c;">append</span><span>(&amp;candidate_moves, Move{hex, tile})
</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> CONNECTION_FLAGS {
</span><span>                nbr_hex  := hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>                nbr_idx, in_bounds := </span><span style="color:#62a35c;">hex_to_index</span><span>(nbr_hex)
</span><span>                nbr_tile := game.board[nbr_idx] </span><span style="font-style:italic;color:#969896;">// nbr_idx == 0 when out
</span><span>
</span><span>                ((!in_bounds &amp;&amp; flag </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> tile) ||
</span><span>                 (in_bounds  &amp;&amp; (</span><span style="color:#62a35c;">tile_is_empty</span><span>(nbr_tile) ||
</span><span>  </span><span style="font-style:italic;color:#969896;">/* so much rightward drift */</span><span>  (flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span>     tile &amp;&amp; </span><span style="color:#62a35c;">flag_opposite</span><span>(flag) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span>     nbr_tile) ||
</span><span>  </span><span style="font-style:italic;color:#969896;">/* the line is 102 chars */</span><span>    (flag </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> tile &amp;&amp; </span><span style="color:#62a35c;">flag_opposite</span><span>(flag) </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> nbr_tile)))) </span><span style="font-weight:bold;color:#a71d5d;">or_break
</span><span>
</span><span>                score += </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> cond </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#0086b3;">0
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// todo: deal with Oscillation
</span><span>}
</span></code></pre>
<h3 id="oscillation">Oscillation</h3>
<p>Now, back to Oscillation. What's that again?</p>
<p>When a Group has no Liberties, it is converted to the other side. If, upon conversion, it  <em>still</em> has no Liberties, it flips again, and .. well .. oscillates. That's illegal!</p>
<p>So Oscillation as a result of a Move can only happen if a Group has only one Liberty and the Move is on <em>that</em> Hex. So I will make a number of assumptions here:</p>
<ol>
<li>If the Move connects only to <em>extendable</em> Groups (Friendly or Enemy), and takes away their last Liberty, it is Oscillation.</li>
<li>If the Move connects to a usual Group (Friendly or Enemy), it is <em>not</em> Oscillation, but either a Capture or a Suicide. (If the surrounding Groups had no other Liberties of their own, they'd be Captured already).</li>
</ol>
<p>I do not know if these assumptions would actually work out. A more sure approach is to actually just ... make the move, and should there be an Oscillation, reject it, and roll back the changes. While it is possible, it would make the list of legal moves <em>wrong</em>, as it might include these Oscillation moves.</p>
<p>Encoding these rules in the loop above is perhaps the best option. It would save an allocation of <code>candidate_moves</code>, and it is already iterating the edges and the neighbors. It could have its own tracker and score. This is how it currently looks:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// ------- same as before, minus the temporary `candidate_moves`
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> hex </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> playable_hexes {
</span><span>        idx := </span><span style="color:#62a35c;">hex_to_index</span><span>(hex)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> friendly_hand {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) </span><span style="font-weight:bold;color:#a71d5d;">do continue
</span><span>
</span><span>            score   := </span><span style="color:#0086b3;">0 </span><span style="font-style:italic;color:#969896;">// if score is 6, tile is playable.
</span><span>            osc_pen := </span><span style="color:#0086b3;">0 </span><span style="font-style:italic;color:#969896;">// unless this is equal to Tile cardinality
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">defer if</span><span> score == </span><span style="color:#0086b3;">6</span><span> &amp;&amp; osc_pen != </span><span style="color:#62a35c;">card</span><span>(tile &amp; CONNECTION_FLAGS) {
</span><span>                </span><span style="color:#62a35c;">append</span><span>(&amp;game.legal_moves, Move{hex, tile})
</span><span>            }
</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> CONNECTION_FLAGS {
</span><span>                nbr_hex  := hex + </span><span style="color:#62a35c;">flag_dir</span><span>(flag)
</span><span>                nbr_idx, in_bounds := </span><span style="color:#62a35c;">hex_to_index</span><span>(nbr_hex)
</span><span>                nbr_tile := game.board[nbr_idx] </span><span style="font-style:italic;color:#969896;">// nbr_idx == 0 when out
</span><span>
</span><span>                ((!in_bounds &amp;&amp; flag </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> tile) ||
</span><span>                 (in_bounds &amp;&amp; (</span><span style="color:#62a35c;">tile_is_empty</span><span>(nbr_tile) ||
</span><span>                                (flag </span><span style="font-weight:bold;color:#a71d5d;">in</span><span>     tile &amp;&amp; </span><span style="color:#62a35c;">flag_opposite</span><span>(flag) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span>     nbr_tile) ||
</span><span>                                (flag </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> tile &amp;&amp; </span><span style="color:#62a35c;">flag_opposite</span><span>(flag) </span><span style="font-weight:bold;color:#a71d5d;">not_in</span><span> nbr_tile)))) </span><span style="font-weight:bold;color:#a71d5d;">or_break
</span><span>
</span><span>                score += </span><span style="color:#0086b3;">1
</span><span>
</span><span>                </span><span style="font-style:italic;color:#969896;">// Only check for Oscillation if it takes away a Liberty.
</span><span>                (in_bounds &amp;&amp; </span><span style="color:#62a35c;">flag_opposite</span><span>(flag) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> nbr_tile) </span><span style="font-weight:bold;color:#a71d5d;">or_continue
</span><span>
</span><span>                nbr_key  := game.groups_map[nbr_idx]
</span><span>
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(enemy_grps, nbr_key) {
</span><span>                    nbr_grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(enemy_grps, nbr_key)
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">group_life</span><span>(nbr_grp) == </span><span style="color:#0086b3;">1</span><span> &amp;&amp; nbr_grp.extendable {
</span><span>                        osc_pen += </span><span style="color:#0086b3;">1
</span><span>                    }
</span><span>                } </span><span style="font-weight:bold;color:#a71d5d;">else if </span><span style="color:#62a35c;">slotmap_contains_key</span><span>(friendly_grps, nbr_key) {
</span><span>                    nbr_grp := </span><span style="color:#62a35c;">slotmap_get</span><span>(friendly_grps, nbr_key)
</span><span>                    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">group_life</span><span>(nbr_grp) == </span><span style="color:#0086b3;">1</span><span> &amp;&amp; nbr_grp.extendable {
</span><span>                        osc_pen += </span><span style="color:#0086b3;">1
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>One tiny thing, this is <code>flag_opposite</code> :</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">flag_opposite</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(flag: Tile_Flag) -&gt; (ret: Tile_Flag) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">#partial switch</span><span> flag {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Top_Right: ret = .Btm_Left
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Right:     ret = .Left
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Btm_Right: ret = .Top_Left
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Btm_Left:  ret = .Top_Right
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Left:      ret = .Right
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Top_Left:  ret = .Btm_Right
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>I think it is done!! What's left? Oh, actually using it.</p>
<h2 id="first-bug">First Bug</h2>
<p>Did not take long to find a bug.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">main</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() {
</span><span>    game := </span><span style="color:#62a35c;">game_init</span><span>()
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">game_destroy</span><span>(game)
</span><span>
</span><span>    ok: </span><span style="font-weight:bold;color:#a71d5d;">bool
</span><span>
</span><span>    ok = </span><span style="color:#62a35c;">game_make_move</span><span>(
</span><span>        &amp;game,
</span><span>        Move{hex = {</span><span style="color:#0086b3;">0</span><span>, </span><span style="color:#0086b3;">0</span><span>}, tile = </span><span style="color:#62a35c;">tile_from_id</span><span>(</span><span style="color:#0086b3;">63</span><span>, .Guest)}
</span><span>    )
</span><span>    fmt.</span><span style="color:#62a35c;">printfln</span><span>(</span><span style="color:#183691;">&quot;%v&quot;</span><span>, ok)
</span><span>
</span><span>    ok = </span><span style="color:#62a35c;">game_make_move</span><span>(
</span><span>        &amp;game,
</span><span>        Move{hex = {</span><span style="color:#0086b3;">1</span><span>, </span><span style="color:#0086b3;">0</span><span>}, tile = </span><span style="color:#62a35c;">tile_from_id</span><span>(</span><span style="color:#0086b3;">63</span><span>, .Host)}
</span><span>    )
</span><span>    fmt.</span><span style="color:#62a35c;">printfln</span><span>(</span><span style="color:#183691;">&quot;%v&quot;</span><span>, ok)
</span><span>
</span><span>    fmt.</span><span style="color:#62a35c;">printfln</span><span>(</span><span style="color:#183691;">&quot;%v&quot;</span><span>, game.groups_map)
</span><span>}
</span></code></pre>
<p>Both moves should be legal, and indeed both <code>ok</code>s are true. However, going over the printed output of <code>game.groups_map</code>, I noticed both of these tiles have the exact same Key. (And is in fact the same Key across multiple runs: 4294967297.)</p>
<p>This is an artifact of how the <code>slotmap</code> crate does its thing, as I found out. The problem is that so far I have been operating under the assumption that the Keys produced are, at least reasonably, different from each other, as I have been using this Key in no less than three places to know in which camp does a key belong. (One of them is <code>game_destroy</code>, where it doesn't matter, but still!)</p>
<p>The easy fix would be perhaps to annotate all three lookups with companion look ups to see the owner of the <code>Tile</code> in the corresponding <code>game.board</code> index. But this feels like a bandaid, that also adds another failure point.</p>
<p>Trying different values I came across another bug that apparently triggered an assertion, but it was whether a <code>slotmap</code> contains a key or not. So a fix for this first bug is needed before any procession.</p>
<h2 id="rethinking-the-need-for-slotmap">Rethinking the Need for <code>slotmap</code></h2>
<p>Using a Rust crate for this functionality has a couple of pain points already:</p>
<ul>
<li>I have mentioned this before, but <code>u64</code> Keys are <em>huge</em>. They are much larger than what is needed in this game. The amount of Groups the entire game cannot actually exceed 126. (If all Tiles were played and each Tile had its own Group, which is also impossible.)</li>
<li>Speed of access: the slotmaps are behind pointers and the Groups are behind pointers, and this is checked and accessed multiple times per move.</li>
<li>Compilation: while this set up works fine on my machine <small>TM</small>, compiling a shim Rust crate separately from the main Odin codebase is a bit more effort than what is usually needed. If this were to be set up for users, I would need to include a build system.</li>
<li>WASM: Add to that, while <code>slotmap</code> itself can be compiled to WASM just fine, compiling two languages into one WASM module is .. not the easiest path forward.</li>
<li>Last but not least, undoing the Game state (something which is needed for engines) would be a <em>lot</em> easier if there were no pointers involved.</li>
</ul>
<p>So now what? Is a slotmap-like data structure even the correct decision at all, actually? Slotmap's advantage is reusing existing allocations for deleted items, while <em>not</em> reusing the handles/indices. But if it lives all on the stack, say through a <code>[CELL_COUNT]Group</code> array, it is not possible to grow memory dynamically as needed (since it is all statically allocated), and one would have to allocate for the worst case scenario <em>anyway</em> removing the main advantage there.</p>
<p>One option is to put Groups in a fixed array, and use indices into that array as keys, and simply stop using that index whenever a Group dies. While a real game is never getting to 126 Groups at once, and there is no game database of played Dominions games to analyze and determine the maximum number of Groups in a real game is. Using <a href="https://mindsports.nl/index.php/dagaz/954-dominions">Mindsports' applet</a>, I managed to get to about 92 individual living "groups" at the same time before I got bored.</p>
<p>How would this look like, though? Separate arrays, one for each player? One array for both? If the second, how to distinguish between friendly and enemy groups storage?</p>
<p>My current thinking is to borrow the handle/index++ idea and invent, essentially, my own handle. Honestly I just want an excuse to use Odin's bit fields.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Group_Handle :: </span><span style="font-weight:bold;color:#a71d5d;">bit_field u8</span><span> {
</span><span style="font-style:italic;color:#969896;">//  name:  Type   | Size
</span><span>    idx:   </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>     | </span><span style="color:#0086b3;">6</span><span>,
</span><span>    owner: Player | </span><span style="color:#0086b3;">1</span><span>,
</span><span>    valid: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>   | </span><span style="color:#0086b3;">1</span><span>,
</span><span>}
</span><span>
</span></code></pre>
<p>The <code>idx</code> here cannot, ever, be more than 63, which is all the address space needed for the worst case scenario, and a little bit more. The <code>owner</code> field is one bit, either this player or that player. The last bit is a funny one: it is just to allow using the zero value of the key (where <code>valid</code> is false), as a sentinel value for an empty slot. At first, I considered having the <code>extendable</code> boolean I have had in <code>Group</code>, but that just makes bookkeeping and updating <code>Group</code> status that much harder. <sup class="footnote-reference" id="fr-9-1"><a href="#fn-9">9</a></sup> So now how about this?</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Rethought_Group :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    state:        [CELL_COUNT]Hex_State,
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">using</span><span> status: </span><span style="font-weight:bold;color:#a71d5d;">bit_field u8</span><span> {
</span><span>        extendable: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> | </span><span style="color:#0086b3;">1</span><span>,
</span><span>        alive:      </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span> | </span><span style="color:#0086b3;">1</span><span>,
</span><span>        _padding:   </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>   | </span><span style="color:#0086b3;">6</span><span>, </span><span style="font-style:italic;color:#969896;">// &lt;- ?
</span><span>    },
</span><span>}
</span><span>
</span><span>Group_Store :: </span><span style="font-style:italic;color:#969896;">// todo
</span></code></pre>
<p>The field <code>_padding</code> is there to suppress a compiler warning about boolean-only bit fields being a terrible idea.</p>
<p>Mind you <code>Rethought_Group</code> has two Odin features Ginger Bill dislikes using: <code>using</code> and <code>bool</code>-only <code>bit_field</code>s, and uses them together, with an anonymous <code>bit_field</code> to boot. (I am actually pleasantly surprised this compiles and works at all.) My goal here is to essentially cram both of <code>extendable</code> and <code>alive</code> booleans into one byte, and they do not really make sense to me as their own type, and keep the nice ergonomics of using them. The advised/Ginger Bill-authorized way to write this is the following:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Group_Status :: </span><span style="font-weight:bold;color:#a71d5d;">enum u8</span><span> {
</span><span>    Extendable,
</span><span>    Alive,
</span><span>}
</span><span>Rethought_Group :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    state:  [CELL_COUNT]Hex_State,
</span><span>    status: </span><span style="font-weight:bold;color:#a71d5d;">bit_set</span><span>[Group_Status; </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>],
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">if</span><span> .Extendable </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> grp.status { </span><span style="font-style:italic;color:#969896;">// etc
</span></code></pre>
<p>But I have already been using <code>Group</code> throughout, and I really like just writing this:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">if</span><span> grp.extendable { </span><span style="font-style:italic;color:#969896;">// etc
</span><span>
</span><span style="font-style:italic;color:#969896;">// AND
</span><span>
</span><span>grp.extendable = </span><span style="color:#0086b3;">true
</span></code></pre>
<p>But what is programming if not suppressing compiler warnings and ignoring the advice of more experienced practitioners? <em>Especially</em> the author of the language you are writing in?</p>
<p>Back to business. The first thing needed is to reimplement the <code>slotmap</code> API for the new <code>Group_Store</code>. Here is the original:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_init</span><span>         :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() -&gt; Slot_Map </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_destroy</span><span>      :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map) </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_insert</span><span>       :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, item: Sm_Item) -&gt; Sm_Key </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_contains_key</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; c.</span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_get</span><span>          :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; Sm_Item </span><span style="color:#0086b3;">---
</span><span>    </span><span style="font-weight:bold;color:#795da3;">slotmap_remove</span><span>       :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(sm: Slot_Map, key: Sm_Key)   -&gt; Sm_Item </span><span style="color:#0086b3;">---
</span></code></pre>
<p><code>init</code> and <code>destroy</code> are perhaps not needed, as they exist to manage heap memory. <code>contains_key</code> could be replaced by <code>get</code> (and <code>remove</code>) returning a success or failure value, as is idiomatic in Odin. To ascertain that <code>Group_Store</code> can only return keys of the appropriate Player, some type system hackery would have been of use, but alas I could not make it work. So I replaced it instead with cursed <code>using</code> hackery. (<code>Rethought_Group</code> is just <code>Group</code> here.)</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>Group_Store :: </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span> {
</span><span>    data:        [HAND_SIZE]Group,
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">using</span><span> _meta: </span><span style="font-weight:bold;color:#a71d5d;">bit_field u8</span><span> {
</span><span>        cursor: </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>     | </span><span style="color:#0086b3;">7</span><span>,
</span><span>        player: Player | </span><span style="color:#0086b3;">1</span><span>,
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">store_insert</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(store: ^Group_Store, group: Group) -&gt; Group_Handle {
</span><span>    </span><span style="color:#62a35c;">assert</span><span>(group.alive, </span><span style="color:#183691;">&quot;trying to insert a dead group!&quot;</span><span>)
</span><span>    store.data[store.cursor] = group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> store.cursor += </span><span style="color:#0086b3;">1
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> Group_Handle{idx = store.cursor, owner = store.player, valid = </span><span style="color:#0086b3;">true</span><span>}
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">store_get</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(store: ^Group_Store, key: Group_Handle) -&gt; (ret: ^Group, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    (key.valid &amp;&amp;
</span><span>     store.player == key.owner &amp;&amp;
</span><span>     key.idx &lt; store.cursor &amp;&amp;
</span><span>     store.data[key.idx].alive) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> &amp;store.data[key.idx], </span><span style="color:#0086b3;">true
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#795da3;">store_remove</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(store: ^Group_Store, key: Group_Handle) -&gt; (ret: Group, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    grp := </span><span style="color:#62a35c;">store_get</span><span>(store, player, key) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> grp.alive = </span><span style="color:#0086b3;">false
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> grp^, </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>This covers it, maybe? Time to delete <code>slotmap.odin</code> and get going with some Compiler-Driven Development. I will not reprint all the changed code here, as it would be boring and a slog. Suffice it to say I did an admirable job at it and all the calls to <code>slotmap</code> were handled excellently and appropriately.</p>
<p>Now time to check if that effort fixes that first bug. Here is the test code again (slightly edited):</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">main</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() {
</span><span>    game := </span><span style="color:#62a35c;">game_init</span><span>()
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">game_destroy</span><span>(game)
</span><span>
</span><span>    ok: </span><span style="font-weight:bold;color:#a71d5d;">bool
</span><span>
</span><span>    ok = </span><span style="color:#62a35c;">game_make_move</span><span>(&amp;game, Move{hex = {</span><span style="color:#0086b3;">0</span><span>, </span><span style="color:#0086b3;">0</span><span>}, tile = </span><span style="color:#62a35c;">tile_from_id</span><span>(</span><span style="color:#0086b3;">63</span><span>, .Guest)})
</span><span>    fmt.</span><span style="color:#62a35c;">printfln</span><span>(</span><span style="color:#183691;">&quot;%v&quot;</span><span>, ok)
</span><span>
</span><span>    ok = </span><span style="color:#62a35c;">game_make_move</span><span>(&amp;game, Move{hex = {</span><span style="color:#0086b3;">1</span><span>, </span><span style="color:#0086b3;">0</span><span>}, tile = </span><span style="color:#62a35c;">tile_from_id</span><span>(</span><span style="color:#0086b3;">63</span><span>, .Host)})
</span><span>    fmt.</span><span style="color:#62a35c;">printfln</span><span>(</span><span style="color:#183691;">&quot;%v&quot;</span><span>, ok)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> game.groups_map {
</span><span>        fmt.</span><span style="color:#62a35c;">printf</span><span>(</span><span style="color:#183691;">&quot;%v, &quot;</span><span>, </span><span style="font-weight:bold;color:#a71d5d;">transmute</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>)key)
</span><span>    }
</span><span>}
</span></code></pre>
<p>And voila! It gives two different keys of <code>128</code> and <code>192</code> (though I can't quite tell which is which) I caught a subtle bug while I was going through the code, which gave the need for a <code>valid</code> field in the key, so that it guarantees no valid key is <code>0</code>.</p>
<p>Testing with different pairs of first moves has gone swimmingly. Things get captured when they should and get rejected when they should. But testing a whole game is more difficult to verify looking at <code>stdout</code> printed arrays of numbers. A different visualization is required.</p>
<h2 id="visualizing-the-board">Visualizing the Board</h2>
<p>A hexagonal board does not quite lend itself to being nicely printed in the terminal. Even if the pieces were simple stones (or chess pieces, available nicely as Unicode code points), However, solutions as old as time, or at least as old as monospaced fonts, exist.</p>
<pre style="background-color:#ffffff;color:#323232;"><code><span># pointy representation
</span><span># &quot;Simply&quot; shift the squares each row half a &quot;square&quot;.
</span><span># this is the coordinate system used in the code.
</span><span>
</span><span>      -3  |   |   |   |   |
</span><span>    -2  |   |   |   |   |   |
</span><span>  -1  |   |   |   |   |   |   |
</span><span> 0  |   |   |   |   |   |   |   |
</span><span>   1  |   |   |   |   |   |   | 3
</span><span>     2  |   |   |   |   |   | 2
</span><span>       3  |   |   |   |   | 1
</span><span>            -3  -2  -1  0
</span><span>
</span><span># or _pointier_, without coordinates.
</span><span>
</span><span>            / \ / \ / \ / \
</span><span>           |   |   |   |   |
</span><span>          / \ / \ / \ / \ / \
</span><span>         |   |   |   |   |   |
</span><span>        / \ / \ / \ / \ / \ / \
</span><span>       |   |   |   |   |   |   |
</span><span>      / \ / \ / \ / \ / \ / \ / \
</span><span>     |   |   |   |   |   |   |   |
</span><span>      \ / \ / \ / \ / \ / \ / \ /
</span><span>       |   |   |   |   |   |   |
</span><span>        \ / \ / \ / \ / \ / \ /
</span><span>         |   |   |   |   |   |
</span><span>          \ / \ / \ / \ / \ /
</span><span>           |   |   |   |   |
</span><span>            \ / \ / \ / \ /
</span><span>
</span><span># flat representation
</span><span># letter/number coordinates system
</span><span>                __
</span><span>             __/  \__
</span><span>          __/  \__/  \__
</span><span>       __/  \__/  \__/  \__
</span><span>      /  \__/  \__/  \__/  \
</span><span>     g\__/  \__/  \__/  \__/7
</span><span>      /  \__/  \__/  \__/  \
</span><span>     f\__/  \__/  \__/  \__/6
</span><span>      /  \__/  \__/  \__/  \
</span><span>     e\__/  \__/  \__/  \__/5
</span><span>      /  \__/  \__/  \__/  \
</span><span>     d\__/  \__/  \__/  \__/4
</span><span>        c\__/  \__/  \__/3
</span><span>           b\__/  \__/2
</span><span>              a\__/1
</span></code></pre>
<p>For <a href="https://github.com/asibahi/w9l">my implementation of Havannah</a>, I went with the Flat ASCII representation. However, since the directions are defined as <code>TOP_RIGHT</code>, <code>RIGHT</code>, etc, the Pointy representation is more appropriate. The compact version above is also, well, compact. Perfect for quick visualizations and debugging, especially that the board size in Dominions is much larger.</p>
<p>Rendering the board is the easy part. But pieces in Dominions are distinct from each other, and it is not feasible to just <em>draw</em> the Tile's shape in the terminal. Firstly, that would be a very complex endeavour, and secondly it would balloon the drawing's size. But each tile can be represented, <em>is</em> represented, by a unique number from 1 to 63, plus a flag for the Owner. Using octal numbers, this can be made much nicer.</p>
<p>Octal numbers today are mostly useless. Every language supports them because, well, they cost nothing to add, and they have one niche use in Unix file permissions. The <em>reason</em> they are useful for Unix file permissions is that these come in sets of three flags. So each set can be represented neatly by one octal digit (which stands for three bits).<sup class="footnote-reference" id="fr-10-1"><a href="#fn-10">10</a></sup></p>
<p>It just so happens that the Tiles in this game are also divided in two sets of three bits: three bits for the Right-side connections, and three to the Left-side connections, and two bits for Owner and Controller, <a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#tiles">detailed earlier</a>. This makes it so the <em>right</em> digit represents the <em>right-side</em> connections, and the middle digit, to the <em>left</em> represents the <em>left</em> side connections. The rightmost digit is either <code>0</code> or <code>1</code> donating the Owner, and using ANSI magic, the tile is colored by the Controller's color. Neat, hah?</p>
<p>While this is unusable for an actual playable application meant for humans (a Graphical interface is more suited), it is very useful for debugging the game's status at any given point. With some trial and error, this is the printing code, the result of which I do not know to show on the web without a screenshot.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:encoding/ansi&quot;
</span><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:fmt&quot;
</span><span>
</span><span style="font-weight:bold;color:#795da3;">board_print</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(board: Board) {
</span><span>    w_on_b :: ansi.CSI + ansi.FG_WHITE + </span><span style="color:#183691;">&quot;;&quot;</span><span> + ansi.BG_BLACK + ansi.SGR
</span><span>    b_on_w :: ansi.CSI + ansi.FG_BLACK + </span><span style="color:#183691;">&quot;;&quot;</span><span> + ansi.BG_WHITE + ansi.SGR
</span><span>    end :: ansi.CSI + ansi.RESET + ansi.SGR
</span><span>
</span><span>    row := </span><span style="color:#62a35c;">min</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">i8</span><span>)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> board {
</span><span>        hex := </span><span style="color:#62a35c;">hex_from_index</span><span>(idx)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> hex.y &gt; row {
</span><span>            row = hex.y
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> row != -N </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="color:#183691;">&quot;|&quot;</span><span>)
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; </span><span style="color:#62a35c;">abs</span><span>(row) {
</span><span>                fmt.</span><span style="color:#62a35c;">print</span><span>(</span><span style="color:#183691;">&quot;  &quot;</span><span>)
</span><span>            }
</span><span>        }
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) {
</span><span>            fmt.</span><span style="color:#62a35c;">print</span><span>(</span><span style="color:#183691;">&quot;|   &quot;</span><span>)
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span> .Controller_Is_Host </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> tile {
</span><span>            fmt.</span><span style="color:#62a35c;">printf</span><span>(
</span><span>                </span><span style="color:#183691;">&quot;|&quot;</span><span> + w_on_b + </span><span style="color:#183691;">&quot;%3o&quot;</span><span> + end,
</span><span>                tile &amp; ~{.Controller_Is_Host}
</span><span>            )
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>            fmt.</span><span style="color:#62a35c;">printf</span><span>(</span><span style="color:#183691;">&quot;|&quot;</span><span> + b_on_w + </span><span style="color:#183691;">&quot;%3o&quot;</span><span> + end, tile)
</span><span>        }
</span><span>    }
</span><span>    fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="color:#183691;">&quot;|&quot;</span><span>)
</span><span>}
</span></code></pre>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/printedboard.png" alt="Printed board" /></p>
<p>Perfect. Every other pair of opening moves I tried works as expected. So now is the time for the <strong>Ultimate Test</strong>: transcribe the full example game!</p>
<h2 id="the-example-game">The Example Game</h2>
<p>The full list of moves for the example game is <a href="https://mindsports.nl/index.php/the-pit/526-dominions">here, in the source code of the game's page</a>. Parsing the moves is a fun exercise, even if I will not use the same notation eventually, so I will do that.</p>
<p>The first task is to know how the coordinates map from the Mindsports representation to mine. This one is straightforward, if a bit tricky. The letters are the rows, or the <code>hex.y</code> coordinate, so <code>A to Q</code> map to <code>8 to -8</code> (yes, backwards.) The columns map <code>1 to 17</code> to <code>-8 to 8</code>. The center hex goes from <code>i9</code> to <code>{0, 0}</code>.</p>
<p>The Tile numbers do not map as neatly. <code>P63</code> is the same, but not the others. It is important to know how the directions map between both representations. Amusingly, I found out that the <code>P1</code> tile is <em>also</em> the same, but the Mindsports representation advances counter-clockwise, while mine does it clockwise. So <code>Top_Left</code>, above being <code>32</code>, is here marked as <code>2</code>, and so on. That gives us this:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">tile_mindsports_id</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(id: </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>, player: Player) -&gt; (ret: Tile) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">0</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Top_Right}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">1</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Top_Left}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">2</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Left}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">3</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Btm_Left}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">4</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Btm_Right}
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id &amp; (</span><span style="color:#0086b3;">1</span><span> &lt;&lt; </span><span style="color:#0086b3;">5</span><span>) &gt; </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do</span><span> ret |= {.Right}
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> player {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Host: ret |= HOST_FLAGS
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span> .Guest:
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return
</span><span>}
</span></code></pre>
<p>And to parse each move:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:strconv&quot;
</span><span>
</span><span style="font-weight:bold;color:#795da3;">move_mindsports_parse</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(str: </span><span style="font-weight:bold;color:#a71d5d;">string</span><span>) -&gt; (ret: Move, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) </span><span style="font-weight:bold;color:#a71d5d;">#optional_ok</span><span> {
</span><span>    </span><span style="font-style:italic;color:#969896;">// move format: B[P12p15]
</span><span>
</span><span>    player: Player
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">switch</span><span> str[</span><span style="color:#0086b3;">0</span><span>] {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#183691;">&#39;W&#39;</span><span>: player = .Guest
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case </span><span style="color:#183691;">&#39;B&#39;</span><span>: player = .Host
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">case</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> {}, </span><span style="color:#0086b3;">false
</span><span>    }
</span><span>
</span><span>    c := </span><span style="color:#0086b3;">3
</span><span>    tile: Tile
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> len := </span><span style="color:#0086b3;">2</span><span>; len &gt;= </span><span style="color:#0086b3;">0</span><span>; len -= </span><span style="color:#0086b3;">1</span><span> {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> len == </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do return</span><span> {}, </span><span style="color:#0086b3;">false
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> id, ok := strconv.</span><span style="color:#62a35c;">parse_uint</span><span>(str[c:][:len]); ok {
</span><span>            c += len
</span><span>            tile = </span><span style="color:#62a35c;">tile_mindsports_id</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>(id), player)
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>        }
</span><span>    }
</span><span>
</span><span>    row := N - </span><span style="font-weight:bold;color:#a71d5d;">i8</span><span>(str[c] - </span><span style="color:#183691;">&#39;a&#39;</span><span>)
</span><span>        c += </span><span style="color:#0086b3;">1
</span><span>
</span><span>    col: </span><span style="font-weight:bold;color:#a71d5d;">i8
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> len := </span><span style="color:#0086b3;">2</span><span>; len &gt;= </span><span style="color:#0086b3;">0</span><span>; len -= </span><span style="color:#0086b3;">1</span><span> {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> len == </span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">do return</span><span> {}, </span><span style="color:#0086b3;">false
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> res, ok := strconv.</span><span style="color:#62a35c;">parse_uint</span><span>(str[c:][:len]); ok {
</span><span>            col = </span><span style="font-weight:bold;color:#a71d5d;">i8</span><span>(res) - N - </span><span style="color:#0086b3;">1
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> {tile = tile, hex = {col, row}}, </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>Ok, now it is time to play through the game, where <code>MOVE_LIST</code> is a defined constant:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">main</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>() {
</span><span>    game := </span><span style="color:#62a35c;">game_init</span><span>()
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer </span><span style="color:#62a35c;">game_destroy</span><span>(game)
</span><span>
</span><span>    moves := strings.</span><span style="color:#62a35c;">split</span><span>(MOVE_LIST, </span><span style="color:#183691;">&quot;;&quot;</span><span>)
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> m, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> moves {
</span><span>        move: Move
</span><span>        ok: </span><span style="font-weight:bold;color:#a71d5d;">bool
</span><span>        move, ok = </span><span style="color:#62a35c;">move_mindsports_parse</span><span>(m)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !ok {
</span><span>            fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="color:#183691;">&quot;MOVE PARSER BROKE&quot;</span><span>)
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>        }
</span><span>
</span><span>        fmt.</span><span style="color:#62a35c;">println</span><span>(idx + </span><span style="color:#0086b3;">1</span><span>, m)
</span><span>
</span><span>        ok = </span><span style="color:#62a35c;">game_make_move</span><span>(&amp;game, move)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> !ok {
</span><span>            fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="color:#183691;">&quot;COULD NOT MAKE MOVE&quot;</span><span>)
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">break
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#62a35c;">board_print</span><span>(game.board)
</span><span>
</span><span>        buffer: [</span><span style="color:#0086b3;">2</span><span>]</span><span style="font-weight:bold;color:#a71d5d;">u8
</span><span>        os.</span><span style="color:#62a35c;">read</span><span>(os.stdin, buffer[:]) </span><span style="font-style:italic;color:#969896;">// advancing manually
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now it is possible to go through the game move by move and compare, manually, the results of this program vs the "canonical" game client.</p>
<h2 id="second-bug">Second Bug</h2>
<p>Running the engine hit an assertion at move 44. All the moves prior to that, including Suicides (amusingly enough), worked fine, but move 44 has the first Capture in the game. The move right after this position, where the first player captures at <code>g2</code>:</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/./bug2board.png" alt="Dominions Position Board" />
<img src="https://asibahi.github.io/thoughts/the-garden-of-odin/./bug2ascii.png" alt="Dominions Position ASCII" /></p>
<p>(They are the same. You can even see the first player's suicides as black numbers starting with <code>0</code>).</p>
<p>The capture logic can be found <a href="https://asibahi.github.io/thoughts/the-garden-of-odin/#game-update-state-inner-second-draft">above</a>. The failure happens here:</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// == merge level 2 surrounding friendlies into blessed group
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> level_2_surrounding_friendlies {
</span><span>        temp_grp, ok := </span><span style="color:#62a35c;">store_remove</span><span>(friendly_grps, key)
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(ok) </span><span style="font-style:italic;color:#969896;">// &lt;--- right there.
</span><span>
</span><span>        blessed_grp.state |= temp_grp.state
</span><span>        blessed_grp.extendable &amp;= temp_grp.extendable
</span><span>    }
</span></code></pre>
<p>I am not sure what this was supposed to accomplish, to be honest; and commenting it out, amusingly, progresses the game and resolves that move, until move 50 when it crashes. Unfortunately between both moves the state is <em>all wrong</em>. Either way, the assert that fails is slightly ahead of that loop.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// == go over surrounding enemy groups to see if they&#39;re dead.
</span><span>    capture_occurance := </span><span style="color:#0086b3;">false
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> surrounding_enemy_grps {
</span><span>        temp_grp, ok := </span><span style="color:#62a35c;">store_get</span><span>(enemy_grps, key)
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(ok, </span><span style="color:#183691;">&quot;Enemy slotmap does not have enemy Key&quot;</span><span>) </span><span style="font-style:italic;color:#969896;">// &lt;--- right here
</span><span>        temp_grp.state[</span><span style="color:#62a35c;">hex_to_index</span><span>(move.hex)] |= .Enemy_Connection
</span><span>        </span><span style="font-style:italic;color:#969896;">// --- snip
</span></code></pre>
<p>This part seems too important to comment out, not to mention the all wrong state. Obviously, however, there is a problem in assigning and updating <code>Group</code> keys. Probably some keys are persistent in <code>group_map</code>, and are not getting updated as new <code>Group</code>s happen.</p>
<p>So obviously the next step is to update the board visualization to include both Tiles <em>and</em> Group IDs.</p>
<h2 id="updated-board-visualization">Updated Board Visualization</h2>
<p>To print each row twice, each time with different data, <em>two</em> buffers are needed instead of printing directly. The two buffers are flushed out once per row.<code>string</code>s in Odin are immutable, and to have a string buffer, one needs to dip one's toes into the Odin core library, and use a <code>strings.Builder</code>.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#795da3;">board_print</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(board: Board, grp_map: [CELL_COUNT]Group_Handle) {
</span><span>    w_on_b :: ansi.CSI + ansi.BG_BLACK + </span><span style="color:#183691;">&quot;;&quot;</span><span> + ansi.FG_WHITE + ansi.SGR
</span><span>    b_on_w :: ansi.CSI + ansi.BG_WHITE + </span><span style="color:#183691;">&quot;;&quot;</span><span> + ansi.FG_BLACK + ansi.SGR
</span><span>    end :: ansi.CSI + ansi.RESET + ansi.SGR
</span><span>
</span><span>    tiles_buffer := strings.</span><span style="color:#62a35c;">builder_make</span><span>()
</span><span>    grps_buffer := strings.</span><span style="color:#62a35c;">builder_make</span><span>()
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> strings.</span><span style="color:#62a35c;">builder_destroy</span><span>(&amp;tiles_buffer)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> strings.</span><span style="color:#62a35c;">builder_destroy</span><span>(&amp;grps_buffer)
</span><span>
</span><span>    row := </span><span style="color:#62a35c;">min</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">i8</span><span>)
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> tile, idx </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> board {
</span><span>        hex := </span><span style="color:#62a35c;">hex_from_index</span><span>(idx)
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> hex.y &gt; row {
</span><span>            row = hex.y
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> row != -N {
</span><span>                fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;tiles_buffer, </span><span style="color:#183691;">&quot;|&quot;</span><span>)
</span><span>                fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;grps_buffer, </span><span style="color:#183691;">&quot;|&quot;</span><span>)
</span><span>
</span><span>                fmt.</span><span style="color:#62a35c;">println</span><span>(strings.</span><span style="color:#62a35c;">to_string</span><span>(tiles_buffer))
</span><span>                fmt.</span><span style="color:#62a35c;">println</span><span>(strings.</span><span style="color:#62a35c;">to_string</span><span>(grps_buffer))
</span><span>
</span><span>                strings.</span><span style="color:#62a35c;">builder_reset</span><span>(&amp;tiles_buffer)
</span><span>                strings.</span><span style="color:#62a35c;">builder_reset</span><span>(&amp;grps_buffer)
</span><span>            }
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> _ </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span> ..&lt; </span><span style="color:#62a35c;">abs</span><span>(row) {
</span><span>                fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;tiles_buffer, </span><span style="color:#183691;">&quot;  &quot;</span><span>)
</span><span>                fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;grps_buffer, </span><span style="color:#183691;">&quot;  &quot;</span><span>)
</span><span>            }
</span><span>        }
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">tile_is_empty</span><span>(tile) {
</span><span>            fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;tiles_buffer, </span><span style="color:#183691;">&quot;|   &quot;</span><span>)
</span><span>            fmt.</span><span style="color:#62a35c;">sbprint</span><span>(&amp;grps_buffer, </span><span style="color:#183691;">&quot;|   &quot;</span><span>)
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span> .Controller_Is_Host </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> tile {
</span><span>            fmt.</span><span style="color:#62a35c;">sbprintf</span><span>(
</span><span>                &amp;tiles_buffer,
</span><span>                </span><span style="color:#183691;">&quot;|&quot;</span><span> + w_on_b + </span><span style="color:#183691;">&quot;%3o&quot;</span><span> + end,
</span><span>                tile &amp; ~{.Controller_Is_Host}
</span><span>            )
</span><span>            fmt.</span><span style="color:#62a35c;">sbprintf</span><span>(
</span><span>                &amp;grps_buffer,
</span><span>                </span><span style="color:#183691;">&quot;|&quot;</span><span> + w_on_b + </span><span style="color:#183691;">&quot;%3X&quot;</span><span> + end,
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">transmute</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>)grp_map[idx]
</span><span>            )
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else</span><span> {
</span><span>            fmt.</span><span style="color:#62a35c;">sbprintf</span><span>(
</span><span>                &amp;tiles_buffer,
</span><span>                </span><span style="color:#183691;">&quot;|&quot;</span><span> + b_on_w + </span><span style="color:#183691;">&quot;%3o&quot;</span><span> + end,
</span><span>                tile
</span><span>            )
</span><span>            fmt.</span><span style="color:#62a35c;">sbprintf</span><span>(
</span><span>                &amp;grps_buffer,
</span><span>                </span><span style="color:#183691;">&quot;|&quot;</span><span> + b_on_w + </span><span style="color:#183691;">&quot;%3X&quot;</span><span> + end,
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">transmute</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span>)grp_map[idx]
</span><span>            )
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>There you go, much better.</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/./viz2ascii.png" alt="Visualization with Group IDs" /></p>
<h2 id="back-to-the-second-bug">Back to the Second Bug</h2>
<p>Honestly, I am not enjoying debugging this. I feel it would be easier to rewrite the whole thing with the learned assumptions. But persevere I must.</p>
<p>Going back to move 44, where the first crash happened: All the groups that must be separate are separate, and all the ones that must be connected are connected. So, the easy assumption is that all the code paths triggered so far are correct.</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/./move44ascii.png" alt="Move 44 in the Terminal" /></p>
<p>The offending next move, <code>W[P56q10]</code> does the following, physically:</p>
<ol>
<li>It connects to two enemy groups, <code>C7</code> and <code>C8</code>. And to one friendly group, <code>88</code>.</li>
<li>Groups <code>C7</code> and <code>88</code> both lose all liberties, as does the new placed Tile.</li>
<li>Enemy group <code>C7</code> is captured, as it loses all liberties and is connected, from the other side, to another friendly group <code>87</code>.</li>
<li>The result of this is the newly placed tile, friendly groups <code>88</code>, <code>87</code>, and captured enemy group <code>C7</code> must now all be unified into one new group, ideally should be <code>88</code>.</li>
</ol>
<p>So what does the code actually <em>do</em>? Time to use a debugger.</p>
<h3 id="setting-up-the-debugger">Setting up the Debugger</h3>
<p>Thankfully, due to dabbling in Rust, I already had LLDB installed as a VSCode extension. All is needed for it to work is to create a <code>launch.json</code> file (that's almost filled up already), and have it work on an executable built with:</p>
<pre data-lang="sh" style="background-color:#ffffff;color:#323232;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ odin build . -debug
</span></code></pre>
<p>Using a template from the Odin Discord server and adapting it to macOS (from Windows), I got the following two files in the <code>.vscode</code> directory:</p>
<pre data-lang="json" style="background-color:#ffffff;color:#323232;" class="language-json "><code class="language-json" data-lang="json"><span style="font-style:italic;color:#969896;">// launch.json
</span><span>{
</span><span>  </span><span style="color:#183691;">&quot;version&quot;</span><span>: </span><span style="color:#183691;">&quot;0.2.0&quot;</span><span>,
</span><span>  </span><span style="color:#183691;">&quot;configurations&quot;</span><span>: [
</span><span>    {
</span><span>      </span><span style="color:#183691;">&quot;type&quot;</span><span>: </span><span style="color:#183691;">&quot;lldb&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;request&quot;</span><span>: </span><span style="color:#183691;">&quot;launch&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;preLaunchTask&quot;</span><span>: </span><span style="color:#183691;">&quot;Build&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;name&quot;</span><span>: </span><span style="color:#183691;">&quot;Debug&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;program&quot;</span><span>: </span><span style="color:#183691;">&quot;${workspaceFolder}/build/debug&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;args&quot;</span><span>: [],
</span><span>      </span><span style="color:#183691;">&quot;cwd&quot;</span><span>: </span><span style="color:#183691;">&quot;${workspaceFolder}&quot;</span><span>,
</span><span>    }
</span><span>  ]
</span><span>}
</span></code></pre>
<pre data-lang="json" style="background-color:#ffffff;color:#323232;" class="language-json "><code class="language-json" data-lang="json"><span style="font-style:italic;color:#969896;">// tasks.json
</span><span>{
</span><span>  </span><span style="color:#183691;">&quot;version&quot;</span><span>: </span><span style="color:#183691;">&quot;2.0.0&quot;</span><span>,
</span><span>  </span><span style="color:#183691;">&quot;command&quot;</span><span>: </span><span style="color:#183691;">&quot;&quot;</span><span>,
</span><span>  </span><span style="color:#183691;">&quot;args&quot;</span><span>: [],
</span><span>  </span><span style="color:#183691;">&quot;tasks&quot;</span><span>: [
</span><span>    {
</span><span>      </span><span style="color:#183691;">&quot;label&quot;</span><span>: </span><span style="color:#183691;">&quot;mkdir&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;type&quot;</span><span>: </span><span style="color:#183691;">&quot;shell&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;command&quot;</span><span>: </span><span style="color:#183691;">&quot;mkdir -p build&quot;</span><span>, </span><span style="font-style:italic;color:#969896;">// &lt;-- Does not work on Windows.
</span><span>    },
</span><span>    {
</span><span>      </span><span style="color:#183691;">&quot;label&quot;</span><span>: </span><span style="color:#183691;">&quot;build&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;type&quot;</span><span>: </span><span style="color:#183691;">&quot;shell&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;command&quot;</span><span>: </span><span style="color:#183691;">&quot;odin build . -debug -out:build/debug&quot;</span><span>,
</span><span>      </span><span style="color:#183691;">&quot;group&quot;</span><span>: </span><span style="color:#183691;">&quot;build&quot;
</span><span>    },
</span><span>    {
</span><span>      </span><span style="color:#183691;">&quot;label&quot;</span><span>: </span><span style="color:#183691;">&quot;Build&quot;</span><span>, </span><span style="font-style:italic;color:#969896;">// &lt;-- launch task runs this
</span><span>      </span><span style="color:#183691;">&quot;dependsOn&quot;</span><span>: [
</span><span>        </span><span style="color:#183691;">&quot;mkdir&quot;</span><span>,  </span><span style="font-style:italic;color:#969896;">// which runs this
</span><span>        </span><span style="color:#183691;">&quot;build&quot;   </span><span style="font-style:italic;color:#969896;">// then this
</span><span>      ]
</span><span>    }
</span><span>  ]
</span><span>}
</span></code></pre>
<p>Now all I need to do is set breakpoints and click the VSCode button that says <code>Debug</code>. Yay for technology.</p>
<p>But how to set a conditional breakpoint based on the move number when <code>game_make_move</code> does not know the move number?</p>
<p>Normally, one would either have to set the move number as a global variable, <em>or</em> pass it on as an explicit parameter into every procedure, both are equally annoying. In Odin, I can just use the <code>context</code> system. The <code>Context</code> struct, which is passed implicitly by default to every Odin procedure, contains a <code>user_index</code> field which can be set to whatever. Inside <code>game_make_move</code> or any of its inner procedures, I simply check for <code>context.user_index</code>.</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// inside main
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">context</span><span>.user_index = idx
</span><span>    ok = </span><span style="color:#62a35c;">game_make_move</span><span>(&amp;game, move)
</span></code></pre>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-style:italic;color:#969896;">// inside game_inner_update_state
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> level_2_surrounding_friendlies {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if context</span><span>.user_index &gt;= </span><span style="color:#0086b3;">43</span><span> {
</span><span>            fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">context</span><span>.user_index) </span><span style="font-style:italic;color:#969896;">// &lt;-- set breakpoint here
</span><span>        }
</span><span>        temp_grp, ok := </span><span style="color:#62a35c;">store_remove</span><span>(friendly_grps, key)
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(ok)                          </span><span style="font-style:italic;color:#969896;">// &lt;-- failing assertion
</span><span>        blessed_grp.state |= temp_grp.state
</span><span>        blessed_grp.extendable &amp;= temp_grp.extendable
</span><span>    }
</span></code></pre>
<p>And that's how it looks when reached.</p>
<p><img src="https://asibahi.github.io/thoughts/the-garden-of-odin/./ss_debugger.png" alt="Debugger showing breakpoint. Beware the typo." /></p>
<h3 id="tedious-debugging">Tedious Debugging</h3>
<p>This part is not cohesive writing. I will be listing my findings, but it might not be the easiest thing to follow.</p>
<p>Going through the variables on the left of the debugger view, some things jump out. <code>level_2_surrounding_friendlies</code> has invalid keys. (Literally, <code>valid</code> is set to false.) What seems to be happening is that, earlier a bit, I am setting the just played tile as <code>.Enemy_Connection</code> for the neighboring enemy group. But when when the key is looked up in <code>game.groups_map</code>, it is still set to <code>0</code> as it is not added there yet.</p>
<p>Adding <code>blessed_key</code> to <code>group_map</code> on creation passes the <code>game_make_move</code> procedure fine, but trips on another assertion in <code>game_regen_legal_moves</code>. Apparently, the new group is not in any group store. It is getting removed somehow. Using Odin magic like adding a <code>loc := #caller_location</code> parameter to <code>store_remove</code>, I can get it to print where that remove call was made. (And yes, I could have put in a breakpoint in there too.)</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#183691;">&quot;core:fmt&quot;
</span><span>
</span><span style="font-weight:bold;color:#795da3;">store_remove</span><span> :: </span><span style="font-weight:bold;color:#a71d5d;">proc</span><span>(
</span><span>    store: ^Group_Store,
</span><span>    key: Group_Handle,
</span><span>    loc := </span><span style="font-weight:bold;color:#a71d5d;">#caller_location </span><span style="font-style:italic;color:#969896;">// &lt;-- Default value so call sites don&#39;t change.
</span><span>) -&gt; (ret: Group, ok: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> key.idx == </span><span style="color:#0086b3;">8</span><span> &amp;&amp; key.owner == .Guest { </span><span style="font-style:italic;color:#969896;">// &lt;-- the offending group
</span><span>        fmt.</span><span style="color:#62a35c;">println</span><span>(</span><span style="color:#183691;">&quot;REMOVED HERE:&quot;</span><span>, loc)
</span><span>    }
</span><span>    grp := </span><span style="color:#62a35c;">store_get</span><span>(store, key) </span><span style="font-weight:bold;color:#a71d5d;">or_return
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">defer</span><span> grp.alive = </span><span style="color:#0086b3;">false
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span> grp^, </span><span style="color:#0086b3;">true
</span><span>}
</span></code></pre>
<p>Running it quickly shows it is removed in that <code>level_2_surrounding_friendlies</code> loop. Where the first assert failed. Adding a condition to check for equality with <code>blessed_key</code> like the following, allows the game to hit no more asserts and continue to completion. Yay!</p>
<pre data-lang="odin" style="background-color:#ffffff;color:#323232;" class="language-odin "><code class="language-odin" data-lang="odin"><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> key </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> level_2_surrounding_friendlies {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> key == blessed_key </span><span style="font-weight:bold;color:#a71d5d;">do continue
</span><span>        temp_grp, ok := </span><span style="color:#62a35c;">store_remove</span><span>(friendly_grps, key)
</span><span>        </span><span style="color:#62a35c;">assert</span><span>(ok)
</span><span>
</span><span>        blessed_grp.state |= temp_grp.state
</span><span>        blessed_grp.extendable &amp;= temp_grp.extendable
</span><span>    }
</span></code></pre>
<p>Now that the example game runs to completion without hitting any assertions, time to check the state's correctness. The final position in the game seems to be all correct, so I will consider this implementation now bug free. Maybe for part 2.</p>
<h2 id="what-s-left">What's left?</h2>
<p>Work is not done on this by any means, even if I ascertained it is 100% bug free. (the legal move generator is not thoroughly tested really.) But I have spent a month, on and off, on this and my wife is frankly sick of me. So here is a list of what is left to implement in round 2:</p>
<ol>
<li>Undoing Moves: Necessary for engine implementations, and easy in theory. All is needed really is to copy the game's state into a dynamic array of previous game states. To save memory, only saving previous <code>Board</code>s is required, as they actually have enough data to generate all the remaining fields.</li>
<li>An interactive interface. A way to interact with the game outside of writing procedure calls in <code>main()</code> Either through a wasm module or a CLI interface, or a common interface either one can use.</li>
<li>Nicer, graphic visualization. The ASCII visualization is useful for debugging, but it is not actually playable. This game needs beautiful art and a beautiful Graphical User Interface.</li>
</ol>
<h2 id="lessons-learned">Lessons Learned</h2>
<p>So throughout working on this article (for almost a whole month) I advanced my knowledge about the following:</p>
<ol>
<li>The Odin programming language,</li>
<li>Interop between Odin and Rust (and any other language really),</li>
<li>HTML and CSS and Zola templating (in setting up this website),</li>
<li>Basic usage of LLDB debugging,</li>
</ol>
<p>So,  this was a fun ride. But it is time to move on to something else.</p>
<p>The code here is in the <a href="https://github.com/asibahi/bustan"><code>bustan</code> repository</a>. You can see the evolution of the code, and much of what is in this article, through the git history.</p>
<p>Until later.</p>
<footer class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>As mentioned earlier, the Blank tile is not used in the game. This permits using a sentinel value of <code>0</code> (or really any value with the smallest six bits set to <code>0</code>) to mark an empty cell. Since Tiles are a <code>u8</code> bit-set anyway, why waste memory on pointers (which are wider), or <code>Maybe</code>, which is at least an extra byte in size? I am not thinking <em>too</em> hard about performance (I know nobody will use this), but it is an interesting constraint to keep in mind. <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>I should be careful not to index into <code>Board</code> directly, however. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>I love that <code>move</code> is not a keyword here, which is really annoying in Rust. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>Generational arena, generational handles, handle-based map, a rose by any other name. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>It is <em>Oscillation</em> because the resulting Group has no Liberties, and therefore has no clear Controller, so it <em>oscillates</em> between both colors. This is way the Blank tile has no role in the game: it automatically oscillates. <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-6">
<p>Technically, only a record of whether the last move <em>was</em> a pass is needed, but <code>last_move</code> is semantically clearer than a <code>last_move_was_a_pass</code> (or <code>pass_ends_the_game</code> or <code>the_end_is_nigh</code>) boolean or a <code>player_who_last_made_a_move</code> enum field. It may also be useful to highlight the last move in a GUI. <a href="#fr-6-1">↩</a></p>
</li>
<li id="fn-7">
<p>Rust would <em>totally</em> yell at me. Then tell me to implement the trait to define the behavior myself. <a href="#fr-7-1">↩</a></p>
</li>
<li id="fn-8">
<p>Freeling does not specify in which order captures are processed. I am assuming here the order is the same as Go. Anyway, all this needs to be verified later once (if?) the engine is implemented. <a href="#fr-8-1">↩</a></p>
</li>
<li id="fn-9">
<p>I have been thinking of why Groups need to own their own data anyway? Group membership is clearly delineated in <code>Game.group_map</code> as it currently is (which would become <code>[CELL_COUNT]Group_Handle</code> under the new regime.) Liberties and Enemy Connections can be calculated and collected with a combination of <code>game.groups_map</code> and, well, <code>game.board</code>. But that's another day's battle. <a href="#fr-9-1">↩</a></p>
</li>
<li id="fn-10">
<p>A fuller explanation of file permissions, as irrelevant as they are to this article, <a href="https://docs.nersc.gov/filesystems/unix-file-permissions/">can be found here</a>. <a href="#fr-10-1">↩</a></p>
</li>
</ol>
</footer>
</main>

			
			
				<footer>
					<small>
						
							<a class="mylink" href="mailto:a.sibahi@gmail.com" rel="me">Mail</a>
						
							<a class="mylink" href="https:&#x2F;&#x2F;x.com&#x2F;@asibahi" rel="me">Twitter</a>
						
							<a class="mylink" href="https:&#x2F;&#x2F;typo.social&#x2F;@asibahi" rel="me">typo.social</a>
						
							<a class="mylink" href="https:&#x2F;&#x2F;github.com&#x2F;asibahi" rel="me">GitHub</a>
						
							<a class="mylink" href="https:&#x2F;&#x2F;sr.ht&#x2F;~asibahi&#x2F;" rel="me">SourceHut</a>
						
						
							<a class="mylink" href="https:&#x2F;&#x2F;asibahi.github.io&#x2F;about&#x2F;">Cat</a>
						
					</small>
				</footer>
			
		</div>
	</body>
</html>
